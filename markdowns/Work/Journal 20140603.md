## A memory issue with the MultiInstanceResolver

there is an memory issue with the following MultiInstanceLifetimeManager. 


```
    public class MultiInstanceControlledLifetimeManager : LifetimeManager, IDisposable
    {
        private readonly List<object> _instances = new List<object>();

        /// <summary>
        /// Sets a new value object.
        /// </summary>
        /// <param name="newValue">The new value.</param>
        public override void SetValue(object newValue)
        {
            lock (_instances)
            {
                _instances.Add(newValue);
            }
        }

        /// <summary>
        /// Gets the value. Always returns null to denote that a new instance must be created every single time
        /// </summary>
        /// <returns>Null, meaning no singleton</returns>
        public override object GetValue()
        {
            return null;
        }

        /// <summary>
        /// Removes the value (does nothing)
        /// </summary>
        public override void RemoveValue()
        {
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this); // shut FxCop up
        }

        /// <summary>
        /// Standard Dispose pattern implementation. Not needed, but it keeps FxCop happy.
        /// </summary>
        /// <param name="disposing">Always true, since we don't have a finalizer.</param>
        [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "disposing", Justification = "This method is only here to avoid the other IDisposable warning")]
        protected void Dispose(bool disposing)
        {
            lock (_instances)
            {
                _instances.ForEach(item => item.TryDispose());
                _instances.Clear();
            }
        }
    }


```


while the finding has been summarized here 

Hi Nrupal & Bruce,

It has been reported that the memory usage of DataViewer will keeps going up and we conduct a memory profiling on it. There is one finding regards the MultiIinstanceLifetimeManager which first introduced in app then moved to lib.

The problem with this class is that it keeps strong references to the object that it helps the Unity container to create for the purpose of destroying them when the container is disposed. Well, in  Viewer, there are a lot of objects are created on the fly, some are stored  by the caller (like the DocumentViewModel to represent a views), some are supposed to be thrown away, but because of the  MultiIinstanceLifetimeManager, the object that are supposed to be thrown away are kept in memory, e.g.

            Tasks.Delay(new TimeSpan(0, 0, 1))
                 .ContinueWith(
                     t => OnTableInitialized(),
                     _cancellationTokenSource.Token,
                     TaskContinuationOptions.OnlyOnRanToCompletion,
                     _uiTaskSchedulerService.GetUITaskScheduler())
                 .LogTaskExceptionIfAny(Log);

Checks the code about Tasks.Delay(TimeSpan delayTimeSpan), you will find that each time .Delay is called, a new instance of ITimer is called, and that spins off a new continuation tasks. They are all recorded by the lifetime manager, and in profile, you will find 

 

As you can see, Customer (ITimer implementation) and the tasks friends are among the most significant different class list.

I tried to replace the MultiInstanceLifetmeManager with the microsoft’s PerResolveLifetimeManager (MultInstanceLifetimeManager  does nearly the same in that it create a new instance when every a target type is requested) , the program continue to work just fine, attaching a profiler showing that ITimer and the downstream Tasks are no longer appeared in two memory snapshots’ difference list. 

So I would like to propose 
1.	Removal of the MultiInstanceLifetimeManager from GM-commmon
2.	Replace the MultiInstanceLifetimeManager with PerResolveLifetimeManager or even the default one – TransientLifetimeManager.

Please let me know if you have any questions, or you have different disposition towards the MultiInstanceLifetimeManager. 

## rehash issues in the HyperList implementation 

there is a Rehash issue in the Sonic's HyperList implementation. the problem is that inside the HyperList, there is a Map that keeps track of the holder for quick lookup and there is a list of Holders that paves for the data. we deems two row object as equal when the references are equal, while the problem is that the hash code of the row object can change. thus make the Hash lookup of the not easy to find. 

so the finding summaries are as below. 


Hi Matthew,

We received complaint from users that our application – Data Viewer has memory issues in that the memory keeps going up. 

With the help we found that the memory increase coming from one class from Sonic Core, and the snapshot below should show it (it increase 50K per hour, while on London box, the numbers can go a lot higher because the server is closer and more updates to UI).

 
I tracked down the code down to the Sonic-Core, the version that we are working on is Sonic-Core 3.1.28, and the Sonic-Tabular is 3.1.36-SNAPSHOT.  Where I made some changes to the code source the highlighted ones are what added or changed by me to better help print debug information.

Code below.

```
// ObservableTable.cs 
        private void UpdateRowByPropertyChange(TableChange change)
        {
            var previous = new ObservableRow(m_table.ColumnSet, change.Previous, m_missingColumnBehaviourMode);

            // Find row
            int index = m_rows.IndexOf(previous);

            var row = m_rows[index];

            // We need to guard against the underlying row's hash code changing - we have no control over this.
            int hashCode = row.GetHashCode();

            // Update row
            row.UpdateRowObject(change.Row);

            // Has the hash code changed?
            if (hashCode != row.GetHashCode())
            {
                Log.InfoFormat("the Hahscode has changed : UpdateRowByPropertyChange, index = {0}, previous = {1}, new = {2}", index, change.Previous, change.Row);
                // Re-add to the list - this will cause the row to be re-bucketed in hyperlist's internal dictionary.
                m_rows[index] = row;
            }
        }
```
and the code 

```
// HyperLIst.cs
        public T this[int index]
        {
            get
            {
                ArgUtils.CheckPositive("index", index);

                return m_elements[index].Element;
            }
            set
            {
                ArgUtils.CheckPositive("index", index);

                ObjectHolder<T> holder = m_elements[index];

                T previous = holder.Element;
                holder.Element = value;

                // Update the map to contain the new object
                if (!m_elementHolderMap.Remove(previous))
                {
                    Log.InfoFormat("Failed to remove previous in HyperList.Indexer[index], index = {0}, previous = {1}, new = {2}", index, previous, value);
                }

                m_elementHolderMap.Add(value, holder);
            }
        }
```

SO I get the following 

> 2014-06-03T19:54:15.097120 [INFO ] {Thread: UI} the Hahscode has changed : UpdateRowByPropertyChange, index = 5494, previous = Composite Row ID:5580 ++ [IRSw EUR 2019-05-08, Euribor 6m sw, 2018-05-08T00:00:00Z, 12m, None, -73080000, 1.396, Your.Namespace, decassap, 6/2/2014 4:44:07 PM, 6/2/2014 7:25:54 PM, 6/3/2014 12:44:07 AM, 6/3/2014 3:25:54 AM, 166.14517], new = Composite Row ID:5594 ++ [IRSw EUR 2019-05-08, Euribor 6m sw, 2018-05-08T00:00:00Z, 12m, None, -73080000, 1.396, Your.Namespace, decassap, 6/2/2014 4:44:07 PM, 6/2/2014 7:25:54 PM, 6/3/2014 12:44:07 AM, 6/3/2014 3:25:54 AM, 166.14517]

and 

> 2014-06-03T19:54:15.097120 [INFO ] {Thread: UI} Failed to remove previous in HyperList.Indexer[index], index = 5494, previous = Row: [ KSAD400, CLNA000022383965, IRSw EUR 2019-05-08, Euribor 6m sw, Your.Namespace, decassap, 2018-05-08T00:00:00Z, 12m, None, InterestRateSwap, EUR, IRSwap, Deriv, Deriv, Amends, 2014-06-02T19:25:54.673Z, 2014-06-02T19:25:54.673Z, 2014-06-02T16:44:07.73Z, 6.0, -73080000, 1.396, 166.14517, (null), 7253.225793, -1523.372953, IRSw EUR 2019-05-08, Euribor 6m sw, 2018-05-08T00:00:00Z, 12m, None, -73080000, 1.396, Intl.Plc.LON, decassap, 6/2/2014 4:44:07 PM, 6/2/2014 7:25:54 PM, 6/3/2014 12:44:07 AM, 6/3/2014 3:25:54 AM, 166.14517 ], new = Row: [ KSAD400, CLNA000022383965, IRSw EUR 2019-05-08, Euribor 6m sw, Intl.Plc.LON, decassap, 2018-05-08T00:00:00Z, 12m, None, InterestRateSwap, EUR, IRSwap, Deriv, Deriv, Amends, 2014-06-02T19:25:54.673Z, 2014-06-02T19:25:54.673Z, 2014-06-02T16:44:07.73Z, 6.0, -73080000, 1.396, 166.14517, (null), 7253.225793, -1523.372953, IRSw EUR 2019-05-08, Euribor 6m sw, 2018-05-08T00:00:00Z, 12m, None, -73080000, 1.396, Intl.Plc.LON, decassap, 6/2/2014 4:44:07 PM, 6/2/2014 7:25:54 PM, 6/3/2014 12:44:07 AM, 6/3/2014 3:25:54 AM, 166.14517 ]


So from the log lines what I guess is that the underlying RowObject’s hash code has changed, and the update comes in with a ‘Previous’ and ‘New’ pairs, but the Hyperlist failed to find the  Previous row and to remove from the m_elementHolderMap (m_elementHolderMap.Remove(previous) simply return false); so the upshot is that update did not do a valid update by removing the old ad it keep adding new updates.  So the memory keeps going. 

Based on my finding.  Can I propose 
1.	Enforce the client code to return immutable hash code for the Row object, like automatically assign a random generated UID for each row object on creation and offers no setter.  this has best performance but user has to revamp their codes.
2.	In the HyperList code’s indexer method,  check if the m_elementHolderMap return false, and if it does, do a brute force search and if the brute force search failed, throw to notify users. – This solution might have big performance impact.
3.	Do periodically sync between the list and its holder map, like we keep tracks of the row objects which has changed its hashcode, and spin off a clean-up tasks which wake up when a threshold Is reached or time elapsed to clean those dead row object?

Let me know your thoughts or any question.

P.S. 
The Stack trace that I got is like below. 
> dll!Core.Collections.Generic.HyperList<Tabular.ObjectModel.ObservableRow>.this[int].set(int index, Tabular.ObjectModel.ObservableRow value) Line 315           C#
Tabular.dll!Tabular.ObjectModel.ObservableTable.UpdateRowByPropertyChange(Tabular.ObjectModel.TableChange change) Line 513 + 0x1f bytes     C#
Tabular.dll!Tabular.ObjectModel.ObservableTable.ProcessUpdates(System.Collections.Generic.IEnumerable<Tabular.ObjectModel.TableChange> changes) Line 462 + 0xb bytes    C#
Tabular.dll!Tabular.ObjectModel.ObservableTable.OnTableChanged(Tabular.Providers.ITableProvider provider, System.Collections.Generic.IEnumerable<Tabular.ObjectModel.TableChange> changes) Line 332 + 0x22 bytes     C#
Tabular.dll!Tabular.Providers.TableProviderBase.NotifyTableChanged(System.Collections.Generic.IEnumerable<Tabular.ObjectModel.TableChange> changeSet) Line 357 + 0xf bytes                C#
Tabular.dll!Tabular.Providers.Rule.RuleTableProvider.OnInputTableChanged(Tabular.Providers.ITableProvider provider, System.Collections.Generic.IEnumerable<Tabular.ObjectModel.TableChange> changes) Line 193 + 0xb bytes       C#
Tabular.dll!Tabular.Providers.ProcessTableProviderBase.OnTableChanged(Tabular.Providers.ITableProvider provider, System.Collections.Generic.IEnumerable<Tabular.ObjectModel.TableChange> changes) Line 78 + 0x11 bytes        C#
Tabular.dll!Tabular.Providers.TableProviderBase.NotifyTableChanged(System.Collections.Generic.IEnumerable<Tabular.ObjectModel.TableChange> changeSet) Line 357 + 0xf bytes                C#
          Tabular.dll!Tabular.Providers.Join.JoinTableProvider.OnJoinUpdated(object sender, Tabular.ObjectModel.TableChangeEventArgs e) Line 402 + 0xb bytes          C#
Tabular.dll!Tabular.Providers.Join.JoinImpl.OnJoinUpdated(System.Collections.Generic.IEnumerable<Tabular.ObjectModel.TableChange> changes) Line 497 + 0x32 bytes  C#
               Tabular.dll!Tabular.Providers.Join.JoinImpl.ProcessJoinRowInsert(object joinRow) Line 447 + 0xb bytes    C#
Tabular.dll!Tabular.Providers.Join.JoinImpl.OnTableChanged(Tabular.Providers.ITableProvider provider, System.Collections.Generic.IEnumerable<Tabular.ObjectModel.TableChange> changes) Line 395 + 0x1e bytes     C#
Tabular.dll!Tabular.Providers.TableProviderBase.NotifyTableChanged(System.Collections.Generic.IEnumerable<Tabular.ObjectModel.TableChange> changeSet) Line 357 + 0xf bytes                C#
Tabular.dll!Tabular.Providers.Fabric.FabricTableProvider.OnBatchEnd(Connect.Services.Data.ObjectModel.IDataFabric fabric, Connect.Services.Data.ObjectModel.IDataFabricContributor contributor) Line 585 + 0xe bytes                C#
dll!Connect.Services.Data.ObjectModel.UntypedDataFabricListenerWrapper<Aggregation.AggregatedData>.OnBatchEnd(Connect.Services.Data.ObjectModel.IDataFabric<Aggregation.AggregatedData> fabric, Connect.Services.Data.ObjectModel.IDataFabricContributor contributor) Line 123 + 0x18 bytes                C#
dll!Connect.Services.Data.ObjectModel.DataFabricImpl<Aggregation.AggregatedData>.OnBatchEnd(Connect.Services.Data.ObjectModel.IDataFabricContributor contributor) Line 1126 + 0x5a bytes         C#
dll!Connect.Services.Data.ObjectModel.DataFabricImpl<Aggregation.AggregatedData>.NotifyBatchEnd(Connect.Services.Data.ObjectModel.IDataFabricContributor contributor) Line 948 + 0xb bytes              C#
dll!Connect.Services.Data.ObjectModel.DataFabricImpl<Aggregation.AggregatedData>.DataFabricContributorAdaptor<Aggregation.AggregatedData>.NotifyBatchEnd() Line 1375 + 0x10 bytes   C#
Interface.dll!YourOrganization.Utils.SyncContextDataFabricContribution.NotifyBatchEnd.AnonymousMethod__7(object o) Line 69 + 0xc bytes     C#
               [External Code]                


well, according to Matt, this problem has been fixed, in the Jira description [SONIC-872
Observable Table can't handle objects with changing hash codes - STILL!](http://dev-tools.YourOrganization.com:8080/ETCB/your_orgjira/browse/SONIC-872), this has been written 

> * Modified HyperList so that elements can be re-hashed without having to be removed and reinserted.
* Modified ObservableTable to use this mechanism.
* Modified Row to only snap to underlying object's hash code when instructed. This allows the row to be removed from the map before updating the hash code and being re-inserted.

So if I as to implement the code, I would like to fix the issue like below. 

I would add a Hash code to the Holder, which was first calculted Hahs code, then when the IndexOf method returns the index, through the index get the hashcode, and then with that hashcode to find the maps on that hash code. the lookup dictionary won't store the object itself as the key, instead it will store the hashcode as the key then with that to find the element holder. 

let's continue to explore the code as such...

as Matt has pointed out, the code has been fixed in the follow code branches. 



I checked the code, this is implemented by this : 

```
        public override int GetHashCode()
        {
            // ReSharper disable once NonReadonlyFieldInGetHashCode
            return m_hashCode;
        }

```

the HashCode is created once the Object is created

```
        public Row(IColumnSet columnSet, object rowObject)
        {
            ArgUtils.CheckNotNull("columnSet", columnSet);
            ArgUtils.CheckNotNull("rowObject", rowObject);

            m_columnSet = columnSet;
            RowObject = rowObject;

            m_hashCode = RowObjectHashCode;
        }
```

and it will check if the HashCode has changed. by this : 

```
        public bool HasHashCodeChanged
        {
            get { return (m_hashCode != RowObjectHashCode); }
        }
```

and the UpdateRowByPropertyChange(TableChange change) has this: 

```
        private void UpdateRowByPropertyChange(TableChange change)
        {
            ObservableRow row;
            int index;

            lock (m_lock)
            {
                var previous = new ObservableRow(m_columnSet, change.Previous, m_missingColumnBehaviourMode);

                // Find row
                index = m_rows.IndexOf(previous);
                row = m_rows[index];
            }

            // Update row
            row.UpdateRowObject(change.Row);

            lock(m_lock)
            {
                // We need to guard against the underlying row's hash code changing - we have no control over this.
                // Has the hash code changed?
                if (row.HasHashCodeChanged)
                {
                    // Re-hash in the list - this will cause the row to be re-bucketed in hyperlist's internal dictionary.
                    m_rows.ReHashAt(index, r => r.ReSnapHashCode());
                }
            }
        }
```

the it does a re-hash 

```
        public void ReHashAt(int index, Action<T> rehash)
        {
            ArgUtils.CheckPositive("index", index);

            ObjectHolder<T> holder = m_elements[index];

            T value = holder.Element;

            // Remove the element from the map
            if (!m_elementHolderMap.Remove(value))
            {
                throw new InvalidOperationException("Error rehashing element. Element does not exist.");    
            }

            // Update the hash
            rehash(value);

            // Re-add back to the map, using the new hash code
            m_elementHolderMap.Add(value, holder);
        }
        
```

this all works, because until the rehash, the old Hashcode stay unchanged. check the IndexOf method in the HyperList class.  

```
        public T this[int index]
        {
            get
            {
                ArgUtils.CheckPositive("index", index);

                return m_elements[index].Element;
            }
            set
            {
                ArgUtils.CheckPositive("index", index);

                ObjectHolder<T> holder = m_elements[index];

                T previous = holder.Element;
                holder.Element = value;

                // Update the map to contain the new object
                if (!m_elementHolderMap.Remove(previous))
                {
                    throw new InvalidOperationException("Error replacing element holder. Previous does not exist.");    
                }

                m_elementHolderMap.Add(value, holder);
            }
        }
```

Have to say that the hashcode means is quite genious, however, there is one breaking point in the link, we have to make sure new ObservableRow that wraps around the same Row object has to return the same Hashcode...


However, the correctness of the code has to be yet verified. 


## The RuntimeHelper class

there is a RuntimeHelper class which you can get hold of a number of useful functions, such as the function to return the hash code for a particular object. 

```
        //
        // Summary:
        //     Serves as a hash function for a particular type, suitable for use in hashing
        //     algorithms and data structures such as a hash table.
        //
        // Parameters:
        //   o:
        //     An object to retrieve the hash code for.
        //
        // Returns:
        //     A hash code for the System.Object identified by the o parameter.
        [SecuritySafeCritical]
        public static int GetHashCode(object o);
```

Well, there are more methods offered to the GetHashCode example. such as the following . 

```
  [SecuritySafeCritical]
  public static int GetHashCode(object o);
```

and others

```
    [SecurityCritical]
    public static void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
```

the RuntimeHelpers is the key to the aforementioned Fix to the hash function, as you can find in the [RuntimeHelpers.GetHashCode Method (Object)][runtimehelpers_gethashcode_method] .

> The RuntimeHelpers.GetHashCode method always calls the Object.GetHashCode method non-virtually, even if the object's type has overridden the Object.GetHashCode method. Therefore, using RuntimeHelpers.GetHashCode might differ from calling GetHashCode directly on the object with the Object.GetHashCode method.

so that is the non-overloaded verion of the GetHashCode methods.  

References
[RuntimeHelpers.GetHashCode Method (Object)](http://msdn.microsoft.com/en-us/library/11tbk3h9(v=vs.110).aspx)
[runtimehelpers_gethashcode_method]: http://msdn.microsoft.com/en-us/library/11tbk3h9(v=vs.110).aspx

## the magic to make the total row style corrects 


the magics to make the total rows correct is as follow. 

First Created a ColumnFixedStyleBorderThicknessConverter 

```
using System.Windows;
using System;
using System.Linq;
using System.Windows.Data;
using DevExpress.Xpf.Grid;


    /// <summary>
    /// Column Fixed Style Border Thickness Converter
    /// </summary>
    public class ColumnFixedStyleBorderThicknessConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            GridColumnBase column = value as GridColumnBase;

            if (column != null)
            {
                if (column.Fixed == FixedStyle.Left)
                {
                    var parent = column.Parent as GridControl;
                    if (parent != null)
                    {
                        var lastFixedLeftColumn =
                            parent.Columns.LastOrDefault(
                                p =>
                                (!ReferenceEquals(p, column) && p.Fixed == FixedStyle.Left)
                                || ReferenceEquals(p, column));
                        if (ReferenceEquals(lastFixedLeftColumn, column))
                        {
                            return new Thickness(0);
                        }
                    }
                }
            }

            return new Thickness(0, 0, 1, 0);
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
```

then to use it 

```
    <cnvt:ColumnFixedStyleBorderThicknessConverter x:Key="ColumnFixedStyleBorderThicknessConverter" />

    <ControlTemplate x:Key="{dxgt:TotalSummaryThemeKey ThemeName=ApplicationTheme, ResourceKey=TotalSummaryControlTemplate}">
        <Border Background="Transparent" BorderBrush="{x:Static s:ModuleBrushes.DefaultBorderBrush}" 
                BorderThickness="{Binding Column, Converter={StaticResource ColumnFixedStyleBorderThicknessConverter}}"
                cs:Name="Border_0001">
            <Grid Margin="{TemplateBinding Padding}" Name="rootGrid">
                <Grid.Visibility>
                    <Binding Path="Column.HasTotalSummaries">
                        <Binding.Converter>
                            <dx:BoolToObjectConverter TrueValue="Visible" FalseValue="Hidden" />
                        </Binding.Converter>
                    </Binding>
                </Grid.Visibility>
                <Border Background="Transparent" 
                        BorderThickness="0" 
                        cs:Name="Border_0003">
                    <dxg:TotalSummaryContentPresenter 
                        Content="{Binding}" 
                        ContentTemplateSelector="{Binding Path=Column.View.ActualTotalSummaryItemTemplateSelector}" 
                        DataContext="{Binding Path=DataContext, RelativeSource={RelativeSource TemplatedParent}}" 
                        Style="{Binding Path=Column.ActualTotalSummaryContentStyle}" 
                        />
                </Border>
            </Grid>
        </Border>
    </ControlTemplate>
```
There is a simpler version, called this "FixedStyleBorderThicknessConverter", which has problem when there are more columns to the left. . 

```
// Has problem when more than one columns is to the left.
using System;
using System.Windows;
using System.Windows.Data;
using DevExpress.Xpf.Grid;


    /// <summary>
    /// FixedStyle to Border Thickness Converter
    /// </summary>
    public class FixedStyleBorderThicknessConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            var fixedStyle = FixedStyle.None;
            if (value is FixedStyle)
            {
                fixedStyle = (FixedStyle)value;
            }

            switch (fixedStyle)
            {
                case FixedStyle.Left:
                    return new Thickness(0);
                default:
                    return new Thickness(0, 0, 1, 0);
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

```


## Band and Columns

the Bands and Columns are different means of managing the DevExpress columns

please see the reference section below.


References :

[grandband_member]: https://documentation.devexpress.com/#WPF/DevExpressXpfGridGridControlBandMembersTopicAll
[GridControlBand Member][grandband_member]
[gridcolumn_member]: https://documentation.devexpress.com/#WPF/DevExpressXpfGridGridColumnMembersTopicAll
[GridColumn Member][gridcolumn_member]


## Row style on 2 or more levels of grouping

the problem turns out to the the parameter called 

```
    <sys:Double x:Key="{dxgt:TableViewThemeKey ResourceKey=LeftGroupAreaIndent, ThemeName=ApplicationTheme}">30</sys:Double>
    
```

which is too big, by changing the value, 

```
    <sys:Double x:Key="{dxgt:TableViewThemeKey ResourceKey=LeftGroupAreaIndent, ThemeName=ApplicationTheme}">23</sys:Double>
    
```

it was fixed 

References:
[Nested Group Rows Indent]( http://www.devexpress.com/Support/Center/Question/Details/Q299316)
[Change the group data indent](http://www.devexpress.com/Support/Center/Question/Details/Q296326)

## DevExpress example on displaying the row header 

well, if you want to display the row numbers on the DevExpress grid, there are two ways, one is to use the RowIndicator, and the other is to use the unbound column which is to bind to row index. 

well, we will examine only the RowIndicator one. the code that to implement this is as follow.  

```
<dxg:GridControl.Resources>
<DataTemplate x:Key="{dxgt:RowIndicatorThemeKey ResourceKey=IconPresenterTemplate}">
<StackPanel x:Name="root"
Orientation="Horizontal">
<dxe:TextEdit Text="{Binding RowHandle.Value, Converter={local:RowHandleToStringConverter}, Mode=OneWay}"
HorizontalAlignment="Right"
EditMode="InplaceInactive" />
<ContentPresenter x:Name="iconPresenter"
Content="{x:Null}" />
</StackPanel>
</DataTemplate>
</dxg:GridControl.Resources>

```
and there is a Property that is called `IndicatorWidth ` which you can override to set the width of the RowIndicator. 

References:
[How to show the number for each row in a row indicator in the grid?](https://www.devexpress.com/Support/Center/Question/Details/Q104033)
[Row Numbering in RowIndicator](http://www.devexpress.com/Support/Center/Question/Details/Q266716)
[Adding the Row Number to the Row Indicator.](http://www.devexpress.com/Support/Center/Question/Details/Q318904)


## Multiple UI threads in WPF

well, we all know that we should handle the incoming request in a UI thread, which has higher priority and receives input and occassionally manipulate the UI (Historically, Windows allows UI elements to be accessed only by the thread that created them. This means that a background thread in charge of some long-running task cannot update a text box when it is finished....) 


However, occasionally it is required to have more than one UI thread, as implied by the following.

> Typically, WPF applications start with two threads: one for handling rendering and another for managing the UI. The rendering thread effectively runs hidden in the background while the UI thread receives input, handles events, paints the screen, and runs application code. Most applications use a single UI thread, although in some situations it is best to use several. We’ll discuss this with an example later.


while there is a classic thread on the Threading Model on this regard.

> * [Threading Model][threading_model]


Reference:

[threading_model]: http://msdn.microsoft.com/en-us/library/ms741870.aspx
[Threading Model][threading_model]
[creatig_ui_in_background_threads_in_wpf]: http://stackoverflow.com/questions/8667529/creating-a-ui-in-background-thread-wpf)
[Creating UI in background threads in WpF][creatig_ui_in_background_threads_in_wpf]
[Running WPF Application with Multiple UI Threads][running_wpf_application_in_multiple_ui_threads]
[running_wpf_application_in_multiple_ui_threads]: http://eprystupa.wordpress.com/2008/07/28/running-wpf-application-with-multiple-ui-threads/
[Lauching a WPF Window in a separate Thread, Part 1][launching_a_wpf_window_in_a_separate_thread]
[launching_a_wpf_window_in_a_separate_thread]: http://reedcopsey.com/2011/11/28/launching-a-wpf-window-in-a-separate-thread-part-1/
[Multiple UI Thread in WPF][multiple_ui_thread_in_wpf]
[multiple_ui_thread_in_wpf]: http://www.visiblox.com/blog/posts/2013/12/18/multiple-ui-threads-in-wpf




### the Dispatcher and the VerifyAccess

WPF has a built-in mutual exclusion mechanism that enforces this coordination. Most classes in WPF derive from [DispatcherObject](http://msdn.microsoft.com/en-us/library/system.windows.threading.dispatcherobject.aspx). At construction, a DispatcherObject stores a reference to the Dispatcher linked to the currently running thread. In effect, the DispatcherObject associates with the thread that creates it. During program execution, a DispatcherObject can call its public [VerifyAccess](http://msdn.microsoft.com/en-us/library/system.windows.threading.dispatcherobject.verifyaccess.aspx) method. VerifyAccess examines the Dispatcher associated with the current thread and compares it to the Dispatcher reference stored during construction. If they don’t match, VerifyAccess throws an exception. VerifyAccess is intended to be called at the beginning of every method belonging to a DispatcherObject.

Reference
[threading_model]: http://msdn.microsoft.com/en-us/library/ms741870.aspx
[Threading Model][threading_model]

## Remember to give a name to the Thread that you creat. 

    Unflagged		8336	9	Main Thread	Main Thread	[Managed to Native Transition]	Normal
    Unflagged	>	3504	15	Worker Thread	Worker UI Thread	MultipleUIThreads.MainWindow.ThreadStartingPoint	Normal

while the code is as follow

```
        private void Browse(object sender, RoutedEventArgs e)
        {
            Thread newWindowThread = new Thread(new ThreadStart(ThreadStartingPoint));
            // first we need a STA thread, because it is the Apartment model that the UI thread can lives in
            // then we need to set the IsBackground thread as true, 
            // as this is to tell the process that I am a background thread, and that to indicate no intention to compete for the main UI thread 
            // thorugh I am doing the UI thread tasks.
            newWindowThread.SetApartmentState(ApartmentState.STA);
            newWindowThread.IsBackground = true;

            // However, we need to assign some name to the thread 
            newWindowThread.Name = "Worker UI Thread";
            newWindowThread.Start();
        }
```


## Push Frame and one usage. 

While sometimes that you want to enter some new loops and keep the old loops intact, you can try the PushFrames, which has been introduced in the References page -  [Threading Model][threading_model]

I have wrote one test apps for that .


First, I create the threading helper class... 

```
using System.Windows.Threading;

namespace PushFrameDemo1.Threadings
{
    /// <summary>
    /// Refers to the Dispathcer.PushFrame method : http://msdn.microsoft.com/zh-cn/library/system.windows.threading.dispatcher.pushframe(v=vs.110).aspx
    /// </summary>
    public class Threading
    {
        public DispatcherOperationCallback FrameAction { get; set; }

        public void DoEvents()
        {
            DispatcherFrame frame = new DispatcherFrame();
            // this can simuate that we create some action that will be executed on a nexted loop
            // as according to [DispatcherFramer Class]: http://msdn.microsoft.com/zh-cn/library/system.windows.threading.dispatcherframe(v=vs.110).aspx
            // Dispatcher Frame represent "an execution loop in the Dispatcher".
            Dispatcher.CurrentDispatcher.BeginInvoke(
                //DispatcherPriority.Background, new DispatcherOperationCallback(ExitFrame), frame);
                DispatcherPriority.Background, new DispatcherOperationCallback(FrameAction), frame);
            Dispatcher.PushFrame(frame);
        }

        public object ExitFrame(object f)
        {
            // Exit from the Dispatcher frame indicated by the f
            ((DispatcherFrame)f).Continue = false;
            return null;
        }
    }
```

Then MyMessageClass to be displayed in the new Frame. 

```
using System.Windows;
using System.Windows.Threading;

namespace PushFrameDemo1.Views
{
    /// <summary>
    /// Interaction logic for MyMessageBox.xaml
    /// </summary>
    public partial class MyMessageBox : Window
    {
        public Threadings.Threading Threading { get; set; }
        public DispatcherFrame DispatcherFrame { get; set; }

        public MyMessageBox()
        {
            InitializeComponent();
        }

        private void Exit(object sender, RoutedEventArgs e)
        {
            this.Close();
            Threading.ExitFrame(DispatcherFrame);
        }
    }
}
```
its view definition is simply as 

```
<Window x:Class="PushFrameDemo1.Views.MyMessageBox"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MyMessageBox" Height="300" Width="300">
    <StackPanel>
        <Button
            Name="_exit"
            Click="Exit"
            Content="OK">
        </Button>
    </StackPanel>
</Window>
```

The entry class MainWindow class is as follow. 

```
using System.Windows;
using System.Windows.Threading;
using PushFrameDemo1.Threadings;
using PushFrameDemo1.Views;

namespace PushFrameDemo1
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public Threadings.Threading Threading { get; set; }
        public MainWindow()
        {
            InitializeComponent();
        }

        private void Show(object sender, RoutedEventArgs e)
        {
            Threading = new Threading();

            Threading.FrameAction = new DispatcherOperationCallback(ShowMessageBox);
            Threading.DoEvents();
        }

        public object ShowMessageBox(object f)
        {
            var messageBox = new MyMessageBox();
            messageBox.DispatcherFrame = (DispatcherFrame)f;
            messageBox.Threading = Threading;
            //messageBox.Show();
            messageBox.ShowDialog();
            return null;
        }
    }
}
```

the View part is 
```
<Window x:Class="PushFrameDemo1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525">
    <StackPanel>
        <Button
            Name="_show"
            Content="Show Mywindow"
            Click="Show"
            ></Button>
    </StackPanel>
</Window>
```

the code is simply as create a new DispatcherFrame,  while this code might not be all right, we will come back to revisit it.

There is a discussion on the [DispatcherFrame. Look in-Depth].

References:
[threading_model]: http://msdn.microsoft.com/en-us/library/ms741870.aspx
[Threading Model][threading_model]
[Dispatcher.PushFrame Method][Dispatcher.PushFrame Method]
[Dispatcher.PushFrame Method]: http://msdn.microsoft.com/zh-cn/library/system.windows.threading.dispatcher.pushframe(v=vs.110).aspx
[DispatcherFrame Class][DispatcherFrame Class]
[DispatcherFrame Class]: http://msdn.microsoft.com/zh-cn/library/system.windows.threading.dispatcherframe(v=vs.110).aspx
[DispatcherFrame. Look in-Depth]: http://www.codeproject.com/Articles/152137/DispatcherFrame-Look-in-Depth
[DispatcherFrame. Look in-Depth]

## DependencyProperty.GetCurrentValue and the DependencyProperty.SetValue()

there are two methods with the similar name called 

* SetCurrentValue 
* SetValue 
the difference is that 

> This method is used by a component that programmatically sets the value of one of its own properties without disabling an application's declared use of the property. The SetCurrentValue method changes the effective value of the property, but existing triggers, data bindings, and styles will continue to work.


while the author gives this: 

```
<TextBox Text="{Binding SomeProperty}"/>
```

> In your control's code, if you call SetValue you will overwrite the binding with whatever you provide. If you call SetCurrentValue, however, will ensure that the property takes on the given value, but won't destroy any bindings.


Check the references: [Whats the difference between Dependency Property SetValue() & SetCurrentValue()]
and 
[Use Set CurrentValue When You Want to Set a Dependency Property Value from within the Control]

References
[Whats the difference between Dependency Property SetValue() & SetCurrentValue()]: http://stackoverflow.com/questions/4230698/whats-the-difference-between-dependency-property-setvalue-setcurrentvalue
[Whats the difference between Dependency Property SetValue() & SetCurrentValue()]

[Use Set CurrentValue When You Want to Set a Dependency Property Value from within the Control]: http://wpf.2000things.com/2010/12/06/147-use-setcurrentvalue-when-you-want-to-set-a-dependency-property-value-from-within-a-control/
[Use Set CurrentValue When You Want to Set a Dependency Property Value from within the Control]


## Elment's position center of Parent in WPF

in [Bind to element's position relative to a parent in WPF], it proposed to use 

```
DependencyPropertyDescriptor dpd = DependencyPropertyDescriptor.FromProperty(Canvas.TopProperty, typeof(Canvas));

dpd.AddValueChanged(canvas1, new EventHandler(topChangedCallback));
```

While if you bind to the Primary Windows' center, you can do the following. [How do you center your main window in WPF?]

```
private void CenterWindowOnScreen()
    {
        double screenWidth = System.Windows.SystemParameters.PrimaryScreenWidth;
        double screenHeight = System.Windows.SystemParameters.PrimaryScreenHeight;
        double windowWidth = this.Width;
        double windowHeight = this.Height;
        this.Left = (screenWidth / 2) - (windowWidth / 2);
        this.Top = (screenHeight / 2) - (windowHeight / 2);
    }
```

Or if you want to make it simple, here is what you can do when launch a new application.

```
window.WindowStartupLocation = WindowStartupLocation.CenterScreen;
```

Or if you want to be absolute center, here is the deal

```
Rect workArea = System.Windows.SystemParameters.WorkArea;
this.Left = (workArea.Width - this.Width) / 2 + workArea.Left;
this.Top = (workArea.Height - this.Height) / 2 + workArea.Top;
```

References:

[Bind to element's position relative to a parent in WPF]: http://stackoverflow.com/questions/1185173/bind-to-elements-position-relative-to-a-parent-in-wpf

[How do you center your main window in WPF?]: http://stackoverflow.com/questions/4019831/how-do-you-center-your-main-window-in-wpf


## Databinding does not seems to work on multiple UI threads settings

There is such a requirement that the UI is doing heavy tasks, and that tasks can only be completed on the UI threads (Like restoring a layout and create UI elements) 

the code that start the UI on a separate threads looks like the following.

```
    /// <summary>
    /// Busy Indicator Service
    /// When the UI thread is busy to inform user that the UI is still responding, spawn a new background to host busy indicator
    /// </summary>
    public class BusyIndicatorService : IBusyIndicatorService, IDisposable
    {
        #region Fields (Locking) 
        private static readonly object _lock = new object(); 
        #endregion

        #region Fields
        private Thread _worker;
        private BusySpinner _busySpinner;
        private Dispatcher _dispatcher;
        private BusySpinnerViewModel _busyViewModel;
        #endregion

        #region Constructor 
        public BusyIndicatorService()
        {
            _worker = new Thread(LoadSpinning);
            _worker.SetApartmentState(ApartmentState.STA);
            _worker.IsBackground = true;
            _worker.Name = "BusyIndicator Worker Thread";
            _busyViewModel = new BusySpinnerViewModel();
        }
        #endregion
                private void LoadSpinning()
        {
            lock (_lock)
            {
                // Install the Dispatcher Synchronization context 
                SynchronizationContext.SetSynchronizationContext(
                    new DispatcherSynchronizationContext(
                        Dispatcher.CurrentDispatcher));
                _dispatcher = Dispatcher.CurrentDispatcher;
                _busySpinner = new BusySpinner();

                _busySpinner.DataContext = _busyViewModel;
                _busySpinner.Setup();
            }

            if (_busyViewModel.AdornContent != null)
            {
                _busySpinner.Show();
            }

            Dispatcher.Run();
        }
    }
}
```


the problem is that I created a ViewMOdel class, its content is as follow.  

```
/// <summary>
    /// View models for the Busy Spinner
    /// </summary>
    internal class BusySpinnerViewModel : NotificationObject
    {
        #region Properties
        
        public FrameworkElement AdornContent
        {
            get; set;// for space reasons, the Notification Parts has been omitted. 
        }

        public double Size
        {
            get; set;
        }

        public double Left
        {
            get; set;
        }

        public double Top
        {
            get; set;
        }

        public bool IsBusy
        {
            get; set;
        }
        #endregion
    }
```

the views code is  as follow 

```
<Window x:Class="BusySpinner"
        x:ClassModifier="internal"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="BusySpinner" 
        WindowStyle="None"
        AllowsTransparency="True"
        xmlns:b="clr-namespace:Controls;assembly=Presentation"
        ResizeMode="NoResize"
        Background="Transparent"
        Width={Binding Size}
        Height={Bindng Size}
        ShowInTaskbar="False">
    <b:BusyIndicator
        x:Name="_busyIndicator"
        IsBusy="{Binding IsBusy}"
        IndicatorSize="{Binding Size}"
        IndicatorMode="Icon">
        <b:BusyIndicator.BusyContent>
            <Border>
                <Rectangle
                    Fill="Transparent" />
            </Border>
        </b:BusyIndicator.BusyContent>
    </b:BusyIndicator>
</Window>
```

there is no BindingExceptions on the Logs, but the Width and the Height seems just to ignore the values like the binding value has never had happened. 

I guess that might be that the Render threads is running on the main UI threads, and our Busy indicator is running on a separate threasd with its own set of Dispatcher and message handling, and when the Binding and evaluation on the dedicated thread find it is on a different threads, it choose to ignore the bindings silently.


## Busy indicator on a separate threads 

In this parts, I will introduce you a busy indicator on the background thread technique. well, it is goes against the norm and we should not rely on this background threads to do really heavy lifting but with a small helper on situation such as the Flash screen and situation like a background UI worker (busy indicator for e.g.) 

First, we have a BusyInddicatorService class, and it looks like this: 

```
using System;
using System.Threading;
using System.Windows;
using System.Windows.Threading;


    /// <summary>
    /// Busy Indicator Service
    /// When the UI thread is busy to inform user that the UI is still responding, spawn a new background to host busy indicator
    /// </summary>
    public class BusyIndicatorService : IBusyIndicatorService, IDisposable
    {
        #region Fields (Locking) 
        private static readonly object _lock = new object(); 
        #endregion

        #region Fields
        private Thread _worker;
        private BusySpinner _busySpinner;
        private Dispatcher _dispatcher;
        private BusySpinnerViewModel _busyViewModel;
        #endregion

        #region Constructor 
        public BusyIndicatorService()
        {
            _worker = new Thread(LoadSpinning);
            _worker.SetApartmentState(ApartmentState.STA);
            _worker.IsBackground = true;
            _worker.Name = "BusyIndicator Worker Thread";
            _busyViewModel = new BusySpinnerViewModel();
        }
        #endregion

        #region Properties (IBusyIndicatorService Implementation)
        public bool IsBusy
        {
            set
            {
                lock (_lock)
                {
                    CenterToAdornContent();
                    if (_dispatcher != null)
                    {
                        _dispatcher.BeginInvoke((Action)(() => _busyViewModel.IsBusy = value), DispatcherPriority.Background, null);
                    }
                    else
                    {
                        _busyViewModel.IsBusy = value;
                       Show();
                    }
                }
            }
        }

        public FrameworkElement AdornContent
        {
            set
            {
                lock (_lock)
                {
                    if (_dispatcher != null)
                    {
                        _dispatcher.BeginInvoke((Action)(() => _busyViewModel.AdornContent = value), DispatcherPriority.Background, null);
                    }
                    else
                    {
                        _busyViewModel.AdornContent = value;
                    }
                }
            }
        }

        public double Size
        {
            set
            {
                lock (_lock)
                {
                    if (_dispatcher != null)
                    {
                        _dispatcher.BeginInvoke(
                            (Action)(() => _busyViewModel.Size = value), DispatcherPriority.Background, null);
                    }
                    else
                    {
                        _busyViewModel.Size = value;
                    }
                }
            }
        }

        #endregion

        public void CenterToAdornContent()
        {
            if (_busyViewModel != null && _busyViewModel.AdornContent != null)
            {
                var location = _busyViewModel.AdornContent.PointToScreen(new Point(0, 0));
                var width = _busyViewModel.AdornContent.ActualWidth;
                var height = _busyViewModel.AdornContent.ActualHeight;

                if (_dispatcher != null)
                {
                    _dispatcher.BeginInvoke((Action)(() =>
                        {
                            _busyViewModel.Left = location.X + ((width - _busyViewModel.Size) / 2);
                            _busyViewModel.Top = location.Y + ((height - _busyViewModel.Size) / 2);
                        }));
                }
                else
                {
                    _busyViewModel.Left = (SystemParameters.PrimaryScreenWidth - _busyViewModel.Size) / 2;
                    _busyViewModel.Top = (SystemParameters.PrimaryScreenHeight - _busyViewModel.Size) / 2;
                }
            }
        }

        /// <summary>
        /// Stop the Busy indicator
        /// </summary>
        public void Stop()
        {
            IsBusy = false;
            if (_dispatcher != null)
            {
                _dispatcher.BeginInvokeShutdown(DispatcherPriority.Background);
            }
        }

        #region
        public void Dispose()
        {
            if (_busySpinner != null)
            {
                _busySpinner.Close();
            }

            Stop();
        }
        #endregion

        #region Private Helpers

        /// <summary>
        /// Show the Busy indicator
        /// </summary>
        private void Show()
        {
            if (!_worker.IsAlive)
            {
                _worker.Start();
            }
        }

        private void LoadSpinning()
        {
            lock (_lock)
            {
                // Install the Dispatcher Synchronization context 
                SynchronizationContext.SetSynchronizationContext(
                    new DispatcherSynchronizationContext(
                        Dispatcher.CurrentDispatcher));
                _dispatcher = Dispatcher.CurrentDispatcher;
                _busySpinner = new BusySpinner();

                _busySpinner.DataContext = _busyViewModel;
                _busySpinner.Setup();
            }

            if (_busyViewModel.AdornContent != null)
            {
                _busySpinner.Show();
            }

            Dispatcher.Run();
        }
        #endregion
    }

```

To support it to work, we have to create a behavior class so that it can help collect the adorned content ,which is important for the Busy indicator to position itself.

```
using System.Windows;
using System.Windows.Interactivity;


    /// <summary>
    /// The Position Tracking Services
    /// </summary>
    internal class BusyIndicatorAdornContentBehavior : Behavior<FrameworkElement>
    {
        #region DependencyProperty

        public static readonly DependencyProperty BusyIndicatorServiceProperty =
            DependencyProperty.Register(
                "BusyIndicatorService",
                typeof(BusyIndicatorService),
                typeof(BusyIndicatorAdornContentBehavior),
                new PropertyMetadata(null, new PropertyChangedCallback(BusyIndicatorServiceChanged)));

        #endregion

        #region Public Properties
        public BusyIndicatorService BusyIndicatorService
        {
            get
            {
                return (BusyIndicatorService)GetValue(BusyIndicatorServiceProperty);
            }

            set
            {
                SetValue(BusyIndicatorServiceProperty, value);
            }
        }


        public double Size
        {
            get; 
            set;
        }

        #endregion

        #region Handlers

        private static void BusyIndicatorServiceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var behavior = d as BusyIndicatorAdornContentBehavior;
            if (behavior != null)
            {
                behavior.BusyIndicatorService.AdornContent = behavior.AssociatedObject;
                behavior.BusyIndicatorService.Size = behavior.Size;
            }
        }
        #endregion
    }

```

while the BusyIndicator will create a BusySpinner on the background threads, the BusyIndicator's xaml code is as follow. 

```
<Window x:Class="BusySpinner"
        x:ClassModifier="internal"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="BusySpinner" 
        WindowStyle="None"
        AllowsTransparency="True"
        xmlns:b="clr-namespace:Controls;assembly=Presentation"
        ResizeMode="NoResize"
        Background="Transparent"
        ShowInTaskbar="False">
    <b:BusyIndicator
        x:Name="_busyIndicator"
        IsBusy="{Binding IsBusy}"
        IndicatorMode="Icon">
        <b:BusyIndicator.BusyContent>
            <Border>
                <Rectangle
                    Fill="Transparent" />
            </Border>
        </b:BusyIndicator.BusyContent>
    </b:BusyIndicator>
</Window>
```

No doubt, it does not use the databinding which shall be a typical wpf application would to use as MVVM pattern. the reason is because the databinding may properly not works because the databinging or render process may works on the Main Ui threads, not on some backgrond UI threads.

In order to bridge the gap because of the shortage, here is what we have on the behind-file...

```
using System.ComponentModel;
using System.Windows;


    /// <summary>
    /// Interaction logic for BusySpinner.xaml
    /// </summary>
    internal partial class BusySpinner : Window
    {
        public BusySpinner()
        {
            InitializeComponent();
        }

        #region Public Method 
        public void Setup()
        {
            if (DataContext != null)
            {
                var notifiableContext = DataContext as BusySpinnerViewModel;
                if (notifiableContext != null)
                {
                    if (!double.IsNaN(notifiableContext.Left))
                    {
                        Left = notifiableContext.Left;
                    }

                    if (!double.IsNaN(notifiableContext.Top))
                    {
                        Top = notifiableContext.Top;
                    }

                    if (!double.IsNaN(notifiableContext.Size))
                    {
                        Width = notifiableContext.Size;
                        Height = notifiableContext.Size;
                        _busyIndicator.IndicatorSize = notifiableContext.Size;
                    }

                    notifiableContext.PropertyChanged += ContextPropertyChanged;
                }
            }
        }

        #endregion

        #region Callbacks

        private void ContextPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            var dataContext = DataContext as BusySpinnerViewModel;
            if (dataContext != null)
            {
                switch (e.PropertyName)
                {
                    case "IsBusy":
                        _busyIndicator.IsBusy = dataContext.IsBusy;
                        if (dataContext.IsBusy)
                        {
                            Show();
                            Activate();
                        }
                        else
                        {
                            Hide();
                        }

                        break;
                    case "Left":
                        Left = dataContext.Left;
                        break;

                    case "Top":
                        Top = dataContext.Top;
                        break;

                    case "Size":
                        Width = dataContext.Size;
                        Height = dataContext.Size;
                        _busyIndicator.IndicatorSize = dataContext.Size;
                        break;
                    default:
                        break;
                }
            }
        }
        #endregion
    }

```

Last but no the least, to support the simple API usage, as shown below, 

```
_busyIndicatorService.IsBusy = true;

_busyIndicatorService.IsBusy = false;

```

we may want to first take the users' input and when actuall the IsBusy is set to true or false, will I then start to show the real window, we need a ViewModel to store the user settings, we don't need to make the ViewModel class NotificationObject, but anyhowe we have made it one, here is the code.

```
using System.Windows;


    /// <summary>
    /// View models for the Busy Spinner
    /// </summary>
    internal class BusySpinnerViewModel : NotificationObject
    {
        private FrameworkElement _adornContent;
        private bool _isBusy;
        private double _size = double.NaN;
        private double _left = double.NaN;
        private double _top = double.NaN;
        #region Fields

        #endregion

        #region Properties

        public FrameworkElement AdornContent
        {
            get
            {
                return _adornContent;
            }

            set
            {
                if (_adornContent != value)
                {
                    _adornContent = value;
                    RaisePropertyChanged(() => AdornContent);
                }
            }
        }

        public double Size
        {
            get
            {
                return _size;
            }

            set
            {
                if (_size != value)
                {
                    _size = value;
                    RaisePropertyChanged(() => Size);
                }
            }
        }

        public double Left
        {
            get
            {
                return _left;
            }

            set
            {
                if (_left != value)
                {
                    _left = value;
                    RaisePropertyChanged(() => Left);
                }
            }
        }

        public double Top
        {
            get
            {
                return _top;
            }

            set
            {
                if (_top != value)
                {
                    _top = value;
                    RaisePropertyChanged(() => Top);
                }
            }
        }

        public bool IsBusy
        {
            get
            {
                return _isBusy;
            }

            set
            {
                if (_isBusy != value)
                {
                    _isBusy = value;
                    RaisePropertyChanged(() => IsBusy);
                }
            }
        }
        #endregion
    }

```


## Databinding path and the notification on middle part of the path


in our code. 

```
          <StackPanel.Style>
            <Style TargetType="{x:Type StackPanel}">
              <Style.Triggers>
                <DataTrigger
                    Binding="{Binding ValuationErrorsViewModel.IsEmpty, Converter={StaticResource InvertBoolean}}"
                    Value="True">
                  <Setter
                      Property="Background"
                      Value="{DynamicResource NegativeBrush}"/>
                </DataTrigger>
                <MultiDataTrigger>
                  <MultiDataTrigger.Conditions>
                    <Condition Binding="{Binding ValuationErrorsViewModel.IsEmpty}" Value="True" />
                    <Condition Binding="{Binding DataViewerFilterViewModel.IsFlash}" Value="True" />
                  </MultiDataTrigger.Conditions>
                  <Setter 
                    Property="Background"
                    Value="{DynamicResource PrimaryLavenderBrush}"/>
                </MultiDataTrigger>
                <MultiDataTrigger>
                  <MultiDataTrigger.Conditions>
                    <Condition Binding="{Binding ValuationErrorsViewModel.IsEmpty}" Value="True" />
                    <Condition Binding="{Binding DataViewerFilterViewModel.IsToday, Converter={StaticResource InvertBoolean}}" Value="True" />
                  </MultiDataTrigger.Conditions>
                  <Setter
                    Property="Background"
                    Value="{DynamicResource PrimaryLavenderBrush}"/>
                </MultiDataTrigger>
              </Style.Triggers>
            </Style>
          </StackPanel.Style>
```

where in the datatrigger, it has 

```
Binding="{Binding ValuationErrorsViewModel.IsEmpty}"
```

while in the code, we have the following. 

```
        private void DataData_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            RaisePropertyChanged(() => ValuationErrorsViewModel);
        }
```
while the binding path is ValuationErrorsViewModel.IsEmpty, the prefix part of the path is ValuationErrorsViewModel, when this has been notified to be changed, the binding has been reevaluated, even though IsEmpty is not a notifiable property (it does not implements the INotifyPropertyChanged interfaces) 


in my case, the code that I have is as follow. 

```
 public void CenterToAdornContent()
        {
            if (_busyViewModel != null && _busyViewModel.AdornContent != null)
            {
                var location = _busyViewModel.AdornContent.PointToScreen(new Point(0, 0));
                var width = _busyViewModel.AdornContent.ActualWidth;
                var height = _busyViewModel.AdornContent.ActualHeight;

                if (_dispatcher != null)
                {
                    _dispatcher.BeginInvoke((Action)(() =>
                        {
                            _busyViewModel.Left = location.X + ((width - _busyViewModel.Size) / 2);
                            _busyViewModel.Top = location.Y + ((height - _busyViewModel.Size) / 2);
                        }));
                }
                else
                {
                    _busyViewModel.Left = (SystemParameters.PrimaryScreenWidth - _busyViewModel.Size) / 2;
                    _busyViewModel.Top = (SystemParameters.PrimaryScreenHeight - _busyViewModel.Size) / 2;
                }
            }
        }
```


can it be that the visual is not yet initialized when the 

## This Visual is not connected to a PresentationSource
This Visual is not connected to a PresentationSource

from the referenced page, it has the following code.  

```
public static Point GetMousePosition(this Visual relativeTo)
{
    return relativeTo.PointFromScreen(GetMousePositionOnScreen());
}
```
one of the answer include 

> There's a static method `PresentationSource.FromVisual` which:

> Returns the source in which a provided Visual is presented.

>  I know this doesn't solve the underlying problem, but you could check that the Visual is connected to a PresentationSource before calling PointFromScreen. It would prevent the exception, but you'd need to do some more investigation as to why it wasn't connected in the first place.

while in troubleshooting the issue I found
1. it won't throw up the first time it is loaded.
2. If you open a new Organizer window and navigate to the Organizer, it won't throw up 
3. If you refresh from an existing window, then the errors will actually happens.


I checked the official site on the PresentationSource part, there are the following .

    Provides an abstract base for classes that present content from another technology as part of an interoperation scenario. In addition, this class provides static methods for working with these sources, as well as the basic visual-layer presentation architecture.

So that matches our case that the Content is actually hosted in a windows 32 container. while in the case of a refresh, what is actually doing is destroy the old view and try to create a new view, after the new view is created, attach that the new view to the container; before the new view is fully connected,  the PresentationSource of this view may not be "presented". so that you might get a Invalid Operation Exception when you try to coordinate translation on a non presented Visual... 

References:

[In WPF, under what circumstances does Visual.PointFromScreen throw InvalidOperationException?](http://stackoverflow.com/questions/2154211/in-wpf-under-what-circumstances-does-visual-pointfromscreen-throw-invalidoperat)
[resentationSource Class](http://msdn.microsoft.com/en-us/library/system.windows.presentationsource(v=vs.110).aspx)


## What is the difference between "*" and "Auto" in WpF

> Auto will make the each column size so it can fit whatever is contained in it.

> "*" will use up the maximum amount of available space. It is best to use when you have a "left over" column that you want to just resize to whatever is left over.

[In WPF, under what circumstances does Visual.PointFromScreen throw InvalidOperationException?](http://stackoverflow.com/questions/2154211/in-wpf-under-what-circumstances-does-visual-pointfromscreen-throw-invalidoperat) 

## Initialization order, constructor, Behavior, and dependency properties

It worth some study of the related order of initialization, below is the code. 

```
    <Grid>
        <s:SnapSplitter
            Margin="0,4,0,4"
            SnapStepSize="300"           
            SplitterSize="30"
            Background="Transparent"
            Orientation="Horizontal">
            <i:Interaction.Behaviors>
                <behaviors:BusyIndicatorAdornContentBehavior 
                    BusyIndicatorService="{Binding DataViewerLayoutManagerViewModel.BusyIndicatorService}"
                    Size="40"/>
            </i:Interaction.Behaviors>
            <s:SnapSplitter.Child1>
                <Grid>
                    <ContentControl
                        Content="{Binding DataViewerFilterViewModel}">
                    </ContentControl>
                </Grid>
            </s:SnapSplitter.Child1>
            <s:SnapSplitter.Child2>
                <Grid>
                    <views:DataViewerLayoutManagerView
                      DataContext="{Binding DataViewerLayoutManagerViewModel}"/>
                </Grid>
            </s:SnapSplitter.Child2>

        </s:SnapSplitter>
    </Grid>
```

while with a debugger, we will see that the 

* Viewmodel is created at first  (constructor)  
* The view (SnapSplitter) is created after it (constructor) 
* the Dependency Properties (thouse that causes some sort of initialization comes after it) - (dependency properties)
* Behavior is attached to it (constructor) 
* Behavior's dependency properties

So the overall order of initialiation is 

* constructor
* dependency properties
* behavior


## MDX equivalent of a filtered GROUP BY in SQL
while the MDX has the group by in nature, while it does not show you how to do some kind of filtered group by clause. 

in this we will show you what to do ,

it all begines with a equivalent SQL statement. the code is as follow. 

```
SELECT 
    g.EnglishCountryRegionName Country
    ,sum(OrderQuantity) as OrderQuantity
FROM dbo.FactResellerSales rs
INNER JOIN dimReseller r
    ON r.ResellerKey = rs.ResellerKey
INNER JOIN dimGeography g
    ON g.GeographyKey = r.GeographyKey
WHERE g.City IN ('Melbourne','Sydney','Seattle','New York')
GROUP BY g.EnglishCountryRegionName
```

while the difficulty is that we are restricting the query on the column axis only on the four cities ...


while the first, but wrong attempt would like to write as such 

```
SELECT 
  [Measures].[Reseller Order Quantity] on 0
  ,{[Geography].[City].[Melbourne]
   ,[Geography].[City].[Sydney]
   ,[Geography].[City].[Seattle]
   ,[Geography].[City].[New York]} on 1 
FROM [Adventure Works] 
```

this is wrong, because it will return countries with all the cities (not only restricted to the four cities mentioned above) . The reason is because is that the where clause in this example can be construed as "find counties which contains one or more of the cities" 

One way is to restrict on the (0 axis), here it is .

```
WITH MEMBER Measures.FilteredSales as 
    SUM(
        EXISTING {[Geography].[City].[Melbourne]
                ,[Geography].[City].[Sydney]
                ,[Geography].[City].[Seattle]
                ,[Geography].[City].[New York]}
   , [Measures].[Reseller Order Quantity])
SELECT 
  {Measures.[FilteredSales]} on 0
  ,[Geography].[Country].[Country].Members on 1 
FROM [Adventure Works] 
WHERE (
    {[Geography].[City].[Melbourne]
    ,[Geography].[City].[Sydney]
    ,[Geography].[City].[Seattle]
    ,[Geography].[City].[New York]})
```



while, this works, it has a very convoluted form. 

we need something simpler. with a sub-query 


```
SELECT 
  [Measures].[Reseller Order Quantity] on 0,
  [Geography].[Country].[Country].Members on 1
FROM ( 
   SELECT
      {[Geography].[City].[Melbourne]
      ,[Geography].[City].[Sydney]
      ,[Geography].[City].[Seattle]
      ,[Geography].[City].[New York]} on 0
FROM [Adventure Works] )
```


while you see, there is only one axis has been specified in the inner select..


References:
[MDX equivalent of a filtered GROUP BY in SQL](http://geekswithblogs.net/darrengosbell/archive/2009/01/28/mdx-equivalent-of-a-filtered-group-by-in-sql.aspx)


## Threading Considerations for Binding and Change Notification in Silverlight 5

The first is wrong, doing the Raise Property on the background thread.

![wrong dispatch][1]

one right one, dispatch the set method 
![Dispatch Set method][2]

Or this is also right, set doing the dispatch
![Set call dispatch][3]

References:
[Threading Considerations for Binding and Change Notification in Silverlight 5][4]

  [1]: http://10rem.net/media/82277/Windows-Live-Writer_Threading-Considerations-for-Binding-in-_EF97_image_13.png
  [2]: http://10rem.net/media/82282/Windows-Live-Writer_Threading-Considerations-for-Binding-in-_EF97_image_22.png
  [3]: http://10rem.net/media/82287/Windows-Live-Writer_Threading-Considerations-for-Binding-in-_EF97_image_24.png
  [4]: http://10rem.net/blog/2012/01/10/threading-considerations-for-binding-and-change-notification-in-silverlight-5
  
  
## Baby's First Garbage Collector
[Baby's First Garbage Collector][baby_first_garbage_collector]

References:
[baby_first_garbage_collector]: http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/
[Baby's First Garbage Collector][baby_first_garbage_collector]

## TemplateBinding and Binding with RelativeSource

I have hte following dependency Property, it is as follow. 

```
            IsDropDownOpenProperty = DependencyProperty.Register(
                "IsDropDownOpen",
                typeof (bool),
                typeof (MultiSelectComboBox),
                new UIPropertyMetadata(false));
```

From the Xaml file, it has the following binding (basically we want when CheckBox is checked, the Popup show, otherwise, hide, also, if we click elsewhere, we hide the Popup)

So we have the following (for the toggleButton)

```
 <ToggleButton
                            x:Name="PART_DropDown"
                            IsChecked="{Binding IsDropDownOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}"
                            Height="24">
                            <ToggleButton.Template>
                                <ControlTemplate>
                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="*" />
                                            <ColumnDefinition Width="18" />
                                        </Grid.ColumnDefinitions>
                                        <Border
                                          Grid.Column="0"
                                          CornerRadius="2"
                                          Margin="1">
                                            <TextBlock
                                      x:Name="PART_SelectedValue"
                                      Text="{Binding SelectedValue, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type mscb:MultiSelectComboBox}}}" />
                                        </Border>
                                        <Border
                                  Grid.Column="1"
                                  Margin="1">
                                            <Path 
                                    x:Name="Arrow"
                                    Grid.Column="1"
                                    HorizontalAlignment="Center"
                                    VerticalAlignment="Center"
                                    Fill="{DynamicResource IconColourBrush}"
                                    Data="M 0 0 L 4 4 L 8 0 Z"/>
                                        </Border>
                                    </Grid>
                                </ControlTemplate>
                            </ToggleButton.Template>
                        </ToggleButton>
```

and this for the Popup

```

                        <Popup
                          x:Name="PART_Popup"
                          Placement="Bottom"
                          SnapsToDevicePixels="True"
                          PopupAnimation="Slide"
                          Width="{TemplateBinding ActualWidth}"
                            IsOpen="{TemplateBinding IsDropDownOpen}"
                            StaysOpen="False"
                          Focusable="False">
                            <Grid>
                                <Border
                                    x:Name="DropDownBorder">
                                    <ScrollViewer VerticalScrollBarVisibility="Auto">
                                        <ItemsControl
                                          ItemsSource="{TemplateBinding ItemsSource}"
                                          ItemsPanel="{TemplateBinding ItemsPanel}"
                                          ItemTemplate="{TemplateBinding ItemTemplate}"/>
                                    </ScrollViewer>
                                </Border>
                            </Grid>
                        </Popup>
```

Notice that 
* TemplateBinding is one way
* Binding with RelativeSource TemplateBinding can works two way

So that for ToggleButton, we have 

```
IsChecked="{Binding IsDropDownOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}"
```

And for popup, we have

```
IsOpen="{TemplateBinding IsDropDownOpen}"
```

also, don't forget the 

```
StaysOpen="False"
```

Reference
[ComboBox Styles and Templates](http://msdn.microsoft.com/en-us/library/ms752094(v=vs.110).aspx)


## Override DefaultStyleKeyProperty and Template

I override certain ItemsSource control to make my own control, here is the definition 

```
    [TemplatePart(Name = PART_DropDown, Type = typeof(ToggleButton))]
    [TemplatePart(Name = PART_SelectedValue, Type = typeof(TextBlock))]
    [TemplatePart(Name = PART_Popup, Type = typeof(Popup))]
    //[TemplatePart(Name = PART_ItemsPresenter, Type = typeof(ItemsPresenter))]
    public class MultiSelectComboBox : ItemsControl
```

To make sure that Style on "ItemsControl" do not affects my control, so I give this in the Static Constructor

```
        static MultiSelectComboBox()
        {
            // http://msdn.microsoft.com/en-us/library/system.windows.frameworkelement.defaultstylekey.aspx
            DefaultStyleKeyProperty.OverrideMetadata(typeof(MultiSelectComboBox), new FrameworkPropertyMetadata(typeof(MultiSelectComboBox)));
        }
```


???? About the Template overrides is not fully understood.
Also, if you desired to specify the default Template (for overrides e.g.) you can also override the Template as following 

```
        static MultiSelectComboBox()
        {
                        // ???
                        TemplateProperty.OverrideMetadata(typeof(MultiSelectComboBox), new FrameworkPropertyMetadata(typeof(MultiSelectComboBox)));
                        
                        // ??? or maybe 
                        TemplateProperty.OverrideMetadata(typeof(MultiSelectComboBox), new FrameworkPropertyMetadata(Template.Resources["ComboBoxToggleButton"]));

        }
```


Reference
[ComboBox Styles and Templates](http://msdn.microsoft.com/en-us/library/ms752094(v=vs.110).aspx)
[DefaultStyleKey Property](http://msdn.microsoft.com/en-us/library/system.windows.frameworkelement.defaultstylekey.aspx)


## Binding on FindAncestor, Binding on TemplateBinding and TemplateBinding 

I have one attributes, which I wrote as such 

```
    <Style TargetType="{x:Type mscb:MultiSelectComboBox}">
        <Setter
            Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type mscb:MultiSelectComboBox}">
                        <!-- ... -->
                         <TextBlock
                                      x:Name="PART_SelectedValue"
                                      Text="{Binding SelectedValue, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type mscb:MultiSelectComboBox}}}" />

```

since it is inside a template, so I can write as such ... 

```
                    <TextBlock
                              x:Name="PART_SelectedValue"
                              Text="{Binding SelectedValue, RelativeSource={RelativeSource TemplatedParent}}" />
```

And I can even boils it down to 


```
                    <TextBlock
                              x:Name="PART_SelectedValue"
                              Text="{TemplateBinding SelectedValue}" />
```


## Wrap, NoWrap, WrapWithOverflow.

References:

[WPF text Wrap vs WrapWithOverflow](http://stackoverflow.com/questions/7348920/wpf-text-wrap-vs-wrapwithoverflow)


## TextTrimming 

References
[Show Ellipsis(…) Button When Text Exceeds Range WPF](http://stackoverflow.com/questions/6869208/show-ellipsis-button-when-text-exceeds-range-wpf)

I have one control that have both the wrapping and the TextTrimming enabled, here is the code.

```
<TextBlock
    x:Name="PART_SelectedValue"
    Text="{Binding SelectedValue, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type mscb:MultiSelectComboBox}}}"
    TextWrapping="NoWrap"
    TextTrimming="CharacterEllipsis"/>
```

## Multi-Select ComboBox in WPF 

[Multi Select ComboBox In WPF](http://www.codeproject.com/Articles/563862/Multi-Select-ComboBox-in-WPF) 

This is my own implemementation of the MultiSelectComboBox , though there are two implemented MultiSelectComboBox in the open source, they are 

1. not correctly implemented
2. Don't have the code and it seems the intended us is quite different from what we would like to have.

#### Choose the right Base class

For my MultiSelectComboBox, I choose to use the ItemsControl, we have the following TemplatePart declared


1. PART_DropDown
2. PART_SelectedValue
3. PART_Popup.

the DropDown is to enable you open the popup, while the SelectedValue is to display the current selected values. the last, the PART_Popup, shows a detailed configuration panel.

the following dependency Properties has been declared... 

1. SelectedValueProperty;
2. IsDropDownOpenProperty;

First is to bind from client the value to displayed, the second is used to synchronized between the dropdown and the popup so that they have consistent state. 

the code is as follow. Notice the following


1. we override the default StyleKey so that it has a default template enabled.
2. It add an owner to the ItemsSource property (not sure if this is necessary)

```
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;

    /// <summary>
    /// MultiSelect Control
    /// </summary>
    [TemplatePart(Name = PART_DropDown, Type = typeof(ToggleButton))]
    [TemplatePart(Name = PART_SelectedValue, Type = typeof(TextBlock))]
    [TemplatePart(Name = PART_Popup, Type = typeof(Popup))]
    //[TemplatePart(Name = PART_ItemsPresenter, Type = typeof(ItemsPresenter))]
    public class MultiSelectComboBox : ItemsControl
    {
        #region Constants
        public const string PART_DropDown = "PART_DropDown";
        public const string PART_SelectedValue = "PART_SelectedValue";
        public const string PART_Popup = "PART_Popup";
        public const string PART_ItemsPresenter = "PART_ItemsPresenter";

        #endregion

        #region Members

        private ToggleButton _dropDownButton;
        private Popup _popUp;
        private ItemsPresenter _itemsPresenter;

        #region Dependency Properties

        public static readonly DependencyProperty SelectedValueProperty;
        public static readonly DependencyProperty IsDropDownOpenProperty;
        //public static readonly DependencyProperty ItemsSourceProperty;

        #endregion

        #endregion
        
        #region Static Constructor 
        static MultiSelectComboBox()
        {
            // http://msdn.microsoft.com/en-us/library/system.windows.frameworkelement.defaultstylekey.aspx
            DefaultStyleKeyProperty.OverrideMetadata(typeof(MultiSelectComboBox), new FrameworkPropertyMetadata(typeof(MultiSelectComboBox)));
            //TemplateProperty.OverrideMetadata(typeof(MultiSelectComboBox), new FrameworkPropertyMetadata(typeof(MultiSelectComboBox)));
            IsDropDownOpenProperty = DependencyProperty.Register(
                "IsDropDownOpen",
                typeof (bool),
                typeof (MultiSelectComboBox),
                new UIPropertyMetadata(false));

            SelectedValueProperty = DependencyProperty.Register(
                "SelectedValue",
                typeof(string),
                typeof(MultiSelectComboBox),
                new FrameworkPropertyMetadata(string.Empty, FrameworkPropertyMetadataOptions.AffectsMeasure));

            ItemsSourceProperty.AddOwner(typeof(MultiSelectComboBox));
        }
        #endregion 

        #region Properties (Dependency)

        public string SelectedValue
        {
            get
            {
                return (string)GetValue(SelectedValueProperty);
            }

            set
            {
                SetValue(SelectedValueProperty, value);
            }
        }
        #endregion

        #region Properties
        internal bool IsPopupOpen
        {
            get; 
            set;
        }
        #endregion

        public override void OnApplyTemplate()
        {
            base.OnApplyTemplate();

            _dropDownButton = Template.FindName(PART_DropDown, this) as ToggleButton;

            _popUp = Template.FindName(PART_Popup, this) as Popup;

            if (_popUp != null)
            {
                _popUp.DataContext = ItemsSource;
            }
        }
    }

```


#### the Template 

In order to make the custom control to work, there must exists some template in order to make it works. 

NOTE the following

1. the template has to conform to the contracts that it has entered with the Code through the use of TemplatePart attributes.
2. It uses of TemplateBinding to the ItemTemplate and the ItemsPanel template. with the nested "itemsControl"

```
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:mscb="clr-namespace:UI.Controls">
    <Style TargetType="{x:Type mscb:MultiSelectComboBox}">
        <Setter
            Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type mscb:MultiSelectComboBox}">
                    <Grid>
                        <ToggleButton
                            x:Name="PART_DropDown"
                            IsChecked="{Binding IsDropDownOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}"
                            Height="24">
                            <ToggleButton.Template>
                                <ControlTemplate>
                                    <Border
                                        BorderThickness="1"
                                        BorderBrush="{DynamicResource DefaultBorderBrush}">
                                        <Grid>
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*" />
                                                <ColumnDefinition Width="18" />
                                            </Grid.ColumnDefinitions>
                                            <Border
                                              Grid.Column="0"
                                              CornerRadius="2"
                                              Margin="1">
                                                <TextBlock
                                                    x:Name="PART_SelectedValue"
                                                    Text="{Binding SelectedValue, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type mscb:MultiSelectComboBox}}}"
                                                    TextWrapping="NoWrap"
                                                    TextTrimming="CharacterEllipsis"/>
                                            </Border>
                                            <Border
                                              Grid.Column="1"
                                              Margin="1">
                                                <Path 
                                                x:Name="Arrow"
                                                Grid.Column="1"
                                                HorizontalAlignment="Center"
                                                VerticalAlignment="Center"
                                                Fill="{DynamicResource IconColourBrush}"
                                                Data="M 0 0 L 4 4 L 8 0 Z"/>
                                            </Border>
                                        </Grid>
                                    </Border>
                                </ControlTemplate>
                            </ToggleButton.Template>
                        </ToggleButton>

                        <Popup
                          x:Name="PART_Popup"
                          Placement="Bottom"
                          SnapsToDevicePixels="True"
                          PopupAnimation="Slide"
                          Width="{TemplateBinding ActualWidth}"
                            IsOpen="{TemplateBinding IsDropDownOpen}"
                            StaysOpen="False"
                          Focusable="False">
                            <Grid>
                                <Border
                                    x:Name="DropDownBorder"
                                    BorderThickness="1"
                                    BorderBrush="{DynamicResource DefaultBorderBrush}">
                                    <ScrollViewer VerticalScrollBarVisibility="Auto">
                                        <ItemsControl
                                          ItemsSource="{TemplateBinding ItemsSource}"
                                          ItemsPanel="{TemplateBinding ItemsPanel}"
                                          ItemTemplate="{TemplateBinding ItemTemplate}"/>
                                    </ScrollViewer>
                                </Border>
                            </Grid>
                        </Popup>
                    </Grid>
                    <ControlTemplate.Triggers>
                        <Trigger
                            Property="HasItems"
                            Value="false">
                            <Setter TargetName="DropDownBorder"
                                Property="MinHeight"
                                Value="95" />
                        </Trigger>
                        <Trigger 
                            Property="IsGrouping"
                            Value="true">
                            <Setter Property="ScrollViewer.CanContentScroll"
                            Value="false" />
                        </Trigger>
                        <Trigger SourceName="PART_Popup"
                           Property="AllowsTransparency"
                           Value="true">
                            <Setter TargetName="DropDownBorder"
                                Property="CornerRadius"
                                Value="4" />
                            <Setter TargetName="DropDownBorder"
                            Property="Margin"
                            Value="0,2,0,0" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
</ResourceDictionary>
```

#### to use the new controls in the client's code 

to use it , we might as well define the style by initializing the "ItemsPanel" and the "ItemTemplate".. here is the code.  

```
            <Style
                x:Key="ValFnGroupOptionsStyle2"
                TargetType="{x:Type mscb:MultiSelectComboBox}"
                BasedOn="{StaticResource {x:Type mscb:MultiSelectComboBox}}">
                <Setter Property="ItemsPanel">
                    <Setter.Value>
                        <ItemsPanelTemplate>
                            <StackPanel Background="{DynamicResource DefaultBackgroundBrush}"/>
                        </ItemsPanelTemplate>
                    </Setter.Value>
                </Setter>
                <Setter
                    Property="ItemTemplate" 
                    Value="{StaticResource ContextItemDataTemplate}" />
            </Style>
```
and the usage of that style.

```
            <GroupBox
                Header="Valuation Function"
                Visibility="{Binding AnyValFnGroupOptions, Converter={StaticResource BooleanToVisibilityConverter}}">
                    <mscb:MultiSelectComboBox
                    SelectedValue="{Binding ValFnGroup, Converter={StaticResource SelectedWidgetOptionsValueConverter}}"
                    ItemsSource="{Binding ValFnGroup}"
                    Style="{StaticResource ValFnGroupOptionsStyle2}" />
            </GroupBox>
```

#### SelectedValue's Converter

in order to show meaning SelectedValue, we have introduced a new Converter, the name being "SelectedWidgetOptionsValueConverter". the converter being:, basically it concats the names of the options.

```
using System.Collections.Generic;
using System.Linq;
using System.Windows.Data;

{
    /// <summary>
    /// Selected Widget Options Converter
    /// </summary>
    public class SelectedWidgetOptionsValueConverter : IValueConverter
    {
        public object Convert(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            var itemsSource = value as IEnumerable<WidgetOptionViewModel>;
            if (itemsSource != null)
            {
                return string.Join(",", itemsSource.Where(item => item.IsSelected).Select(item => item.OptionName));
            }

            return string.Empty;
        }

        public object ConvertBack(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            throw new System.NotImplementedException();
        }
    }
```




References:

[Multi Select ComboBox In WPF](http://www.codeproject.com/Articles/563862/Multi-Select-ComboBox-in-WPF) 
[CheckComboBox](http://wpftoolkit.codeplex.com/wikipage?title=CheckComboBox)

## ColumnarPanel 

sometimes we need to columnarily display the children among the panel so that it has a nice formatted layouts, however, the current layout panel does not allows us to do that, to aid this , I have created the ColumnarPael, the definition is as follow

before showing the code, there are two things that are importants:

1. the Orientation 
2. Columns

the first "Orientation" dictate how the columns show be oriented, whether it is a Horizontal or shall it be a Vertical.. 
The second shows how many columns should ColumnarPanel display with.. 


```
using System;
using System.Windows;
using System.Windows.Controls;

{
    /// <summary>
    /// Columnar Panel
    /// </summary>
    public class ColumnarPanel : Panel
    {
        #region Fileds
        private double _subColMaxWidth = 0.0;
        #endregion

        #region Dependency Property Keys

        // Using a DependencyProperty as the backing store for Orientation.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty OrientationProperty =
            DependencyProperty.Register("Orientation", typeof(Orientation), typeof(ColumnarPanel), new FrameworkPropertyMetadata(Orientation.Vertical, FrameworkPropertyMetadataOptions.AffectsArrange | FrameworkPropertyMetadataOptions.AffectsMeasure));


        // Using a DependencyProperty as the backing store for Column.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty ColumnsProperty =
            DependencyProperty.Register("Columns", typeof(int), typeof(ColumnarPanel), new FrameworkPropertyMetadata(default(int), FrameworkPropertyMetadataOptions.AffectsArrange | FrameworkPropertyMetadataOptions.AffectsMeasure));

        #endregion

        #region Type Initializer 

        static ColumnarPanel()
        {
            FlowDirectionProperty.AddOwner(typeof (ColumnarPanel));
        }

        #endregion

        #region Properties
        public Orientation Orientation
        {
            get { return (Orientation)GetValue(OrientationProperty); }
            set { SetValue(OrientationProperty, value); }
        }

        public int Columns
        {
            get { return (int)GetValue(ColumnsProperty); }
            set { SetValue(ColumnsProperty, value); }
        }
        #endregion

        #region Overrides (Layout)
        protected override Size MeasureOverride(Size availableSize)
        {
            Size desiredSize = new Size(0.0, 0.0);
            int childCount = InternalChildren.Count;
            int childrenPerColumn = (int)Math.Ceiling((double) childCount / Columns);
            int subColOrdinal = -1;
            int subColIndex = -1;
            double subColHeight = 0.0;

            _subColMaxWidth = 0.0;
            foreach (UIElement child in InternalChildren)
            {
                if (subColIndex == childrenPerColumn - 1)
                {
                    subColOrdinal++;

                    // DesiredSize.Height = Max(subColHeight1, subColHeight2, ...)
                    if (Orientation == Orientation.Vertical)
                    {
                         desiredSize.Height = subColHeight > desiredSize.Height ? subColHeight : desiredSize.Height;
                    }
                    else
                    {
                        desiredSize.Width = subColHeight > desiredSize.Height ? subColHeight : desiredSize.Height;
                    }

                    subColIndex = -1;
                    subColHeight = 0.0;
                }

                subColIndex++;
                
                if (child != null)
                {
                    child.Measure(availableSize);
                    _subColMaxWidth = Orientation == Orientation.Vertical ? (child.DesiredSize.Width > _subColMaxWidth ? child.DesiredSize.Width : _subColMaxWidth)
                        : (child.DesiredSize.Height > _subColMaxWidth ? child.DesiredSize.Height : _subColMaxWidth) ;
                    subColHeight += Orientation == Orientation.Vertical ? (child.DesiredSize.Height) 
                        : (child.DesiredSize.Width);
                }
            }

            if (Orientation == Orientation.Vertical)
            {
                desiredSize.Width = _subColMaxWidth * Columns;
            }
            else
            {
                desiredSize.Height = _subColMaxWidth * Columns;
            }

            return desiredSize;
        }

        protected override Size ArrangeOverride(Size finalSize)
        {
            int childCount = InternalChildren.Count;
            int childrenPerColumn = (int)Math.Ceiling((double) childCount / Columns);
            int subColOrdinal = -1;
            int subColIndex = -1;
            double x = 0.0;
            double y = 0.0;
            double maxWidth = finalSize.Width / Columns > _subColMaxWidth ? finalSize.Width / Columns : _subColMaxWidth;

            foreach (UIElement child in InternalChildren)
            {
                 if (subColIndex == childrenPerColumn - 1)
                {
                    subColOrdinal++;

                    subColIndex = -1;
                     if (Orientation == Orientation.Vertical)
                     {
                         y = 0.0;
                         x += maxWidth;
                     }
                     else
                     {
                         x = 0.0;
                         y += maxWidth;
                     }
                }

                subColIndex++;

                var size = new Size(Orientation == Orientation.Vertical ? maxWidth : child.DesiredSize.Width,
                                    Orientation == Orientation.Vertical ? child.DesiredSize.Height : maxWidth);
                child.Arrange(new Rect(new Point(x, y), size));

                if (Orientation == Orientation.Vertical)
                {
                    y += child.DesiredSize.Height;
                }
                else
                {
                    x += child.DesiredSize.Width;
                }
            }

            return finalSize;
        }
        #endregion
    }

```


While I added a second version, which has supports ColumnFillDirection 

```
using System;
using System.Windows;
using System.Windows.Controls;
using System.Linq;


    public enum ColumnFillDirection
    {
        TopDown,
        LeftRight,
    }

    /// <summary>
    /// Columnar Panel
    /// </summary>
    public class ColumnarPanel : Panel
    {
        #region Fileds
        double[] _subColHeights;
        double[] _subColWidths;
        double[] _subColAlignHeights;
        double[] _subColAlignWidths;
        #endregion

        #region Dependency Property Keys

        // Using a DependencyProperty as the backing store for Orientation.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty OrientationProperty =
            DependencyProperty.Register("Orientation", typeof(Orientation), typeof(ColumnarPanel), new FrameworkPropertyMetadata(Orientation.Vertical, FrameworkPropertyMetadataOptions.AffectsArrange | FrameworkPropertyMetadataOptions.AffectsMeasure));

        // Using a DependencyProperty as the backing store for Column.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty ColumnsProperty =
            DependencyProperty.Register("Columns", typeof(int), typeof(ColumnarPanel), new FrameworkPropertyMetadata(default(int), FrameworkPropertyMetadataOptions.AffectsArrange | FrameworkPropertyMetadataOptions.AffectsMeasure));

        public ColumnFillDirection ColumnFillDirection
        {
            get { return (ColumnFillDirection)GetValue(ColumnFillDirectionProperty); }
            set { SetValue(ColumnFillDirectionProperty, value); }
        }

        // Using a DependencyProperty as the backing store for ColumnFillDirection.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty ColumnFillDirectionProperty =
            DependencyProperty.Register("ColumnFillDirection", typeof(ColumnFillDirection), typeof(ColumnarPanel), new FrameworkPropertyMetadata(ColumnFillDirection.TopDown, FrameworkPropertyMetadataOptions.AffectsMeasure | FrameworkPropertyMetadataOptions.AffectsArrange));

        #endregion

        #region Type Initializer 

        static ColumnarPanel()
        {
            FlowDirectionProperty.AddOwner(typeof(ColumnarPanel));
        }

        #endregion

        #region Properties
        public Orientation Orientation
        {
            get { return (Orientation)GetValue(OrientationProperty); }
            set { SetValue(OrientationProperty, value); }
        }

        public int Columns
        {
            get { return (int)GetValue(ColumnsProperty); }
            set { SetValue(ColumnsProperty, value); }
        }
        #endregion

        #region Overrides (Layout)
        protected override Size MeasureOverride(Size availableSize)
        {
            Size desiredSize = new Size(0.0, 0.0);
            int childCount = InternalChildren.Count;
            int childrenPerColumn = (int)Math.Ceiling((double)childCount / Columns);
            int childIndex = 0;
            Size[] fieldSizes = new Size[childCount];
            _subColHeights = new double[Columns];
            _subColWidths = new double[Columns];
            _subColAlignHeights = new double[childrenPerColumn];
            _subColAlignWidths = new double[childrenPerColumn];

            foreach (UIElement child in InternalChildren)
            {
                if (child != null)
                {
                    child.Measure(availableSize);
                    fieldSizes[childIndex++] = child.DesiredSize;
                }
            }

            if (Orientation == Orientation.Vertical)
            {
                for (int i = 0; i < Columns; i++)
                {
                    for (int j = 0; j < childrenPerColumn; j++)
                    {
                        if (ColumnFillDirection == ColumnFillDirection.TopDown)
                        {
                            if (i * childrenPerColumn + j >= childCount)
                            {
                                break;
                            }

                            _subColHeights[i] += fieldSizes[i * childrenPerColumn + j].Height;
                            
                            if (fieldSizes[i*childrenPerColumn + j].Height > _subColAlignHeights[j])
                            {
                                _subColAlignHeights[j] = fieldSizes[i*childrenPerColumn + j].Height;
                            }

                            if (fieldSizes[i * childrenPerColumn + j].Width > _subColWidths[i])
                            {
                                _subColWidths[i] = fieldSizes[i * childrenPerColumn + j].Width;
                            }
                        }
                        else
                        {
                            if (j * Columns + i >= childCount)
                            {
                                break;
                            }

                            if (fieldSizes[j * Columns + i].Height > _subColAlignHeights[j])
                            {
                                _subColAlignHeights[j] = fieldSizes[j * Columns + i].Height;
                            }

                            _subColHeights[i] += fieldSizes[j * Columns + i].Height;
                            if (fieldSizes[j * Columns + i].Width > _subColWidths[i])
                            {
                                _subColWidths[i] = fieldSizes[j * Columns + i].Width;
                            }
                        }
                    }
                }
            }
            else
            {
                for (int i = 0; i < Columns; i++)
                {
                    for (int j = 0; j < childrenPerColumn; j++)
                    {
                        if (ColumnFillDirection == ColumnFillDirection.TopDown)
                        {
                            if (i*childrenPerColumn + j >= childCount)
                            {
                                break;
                            }

                            _subColWidths[i] += fieldSizes[i * childrenPerColumn + j].Width;

                            if (fieldSizes[i * childrenPerColumn + j].Width > _subColAlignWidths[j])
                            {
                                _subColAlignWidths[j] = fieldSizes[i * childrenPerColumn + j].Width;
                            }

                            if (fieldSizes[i * childrenPerColumn + j].Width > _subColHeights[i])
                            {
                                _subColHeights[i] = fieldSizes[i * childrenPerColumn + j].Height;
                            }
                        }
                        else
                        {
                            if (j*Columns + i >= childCount)
                            {
                                break;
                            }

                            _subColWidths[i] += fieldSizes[j * Columns + i].Width;

                            if (fieldSizes[j * Columns + i].Width > _subColAlignWidths[j])
                            {
                                _subColAlignWidths[j] = fieldSizes[j * Columns + i].Width;
                            }

                            if (fieldSizes[j * Columns + i].Width > _subColHeights[i])
                            {
                                _subColHeights[i] = fieldSizes[j * Columns + i].Height;
                            }
                        }
                    }
                }
            }

            if (Orientation == Orientation.Vertical)
            {
                desiredSize.Width = _subColWidths.Max()*Columns;
                desiredSize.Height = _subColHeights.Max();
                if (desiredSize.Height < _subColAlignHeights.Sum())
                {
                    desiredSize.Height = _subColAlignHeights.Sum();
                }
            }
            else
            {
                desiredSize.Width = _subColWidths.Max();
                if (desiredSize.Width < _subColAlignWidths.Sum())
                {
                    desiredSize.Width = _subColAlignWidths.Sum();
                }

                desiredSize.Height = _subColHeights.Max()*Columns;
            }

            return desiredSize;
        }

        protected override Size ArrangeOverride(Size finalSize)
        {
            int childCount = InternalChildren.Count;
            int childrenPerColumn = (int)Math.Ceiling((double)childCount / Columns);
            int childIndex = 0;
            double x = 0.0;
            double y = 0.0;
            double maxWidth = finalSize.Width / Columns > _subColWidths.Max() ? finalSize.Width / Columns : _subColWidths.Max();
            double maxHeight = finalSize.Height / Columns > _subColHeights.Max() ? finalSize.Height / Columns : _subColHeights.Max();

            foreach (UIElement child in InternalChildren)
            {
                Size size;

                if (Orientation == Orientation.Vertical)
                {
                    size = new Size(maxWidth, child.DesiredSize.Height);
                }
                else
                {
                    size = new Size(child.DesiredSize.Width, maxHeight);
                }

                child.Arrange(new Rect(new Point(x, y), size));

                childIndex++;
                if (Orientation == Orientation.Vertical)
                {
                    if (ColumnFillDirection == ColumnFillDirection.TopDown)
                    {
                        y += child.DesiredSize.Height;
                        if (childIndex % childrenPerColumn == 0)
                        {
                            y = 0.0;
                            x += maxWidth;
                        }
                    }
                    else
                    {
                        x += maxWidth;
                        if (childIndex%Columns == 0)
                        {
                            x = 0.0;
                            //y += child.DesiredSize.Height;
                            y += _subColAlignHeights[childIndex/Columns - 1];
                        }
                    }
                }
                else
                {
                    if (ColumnFillDirection == ColumnFillDirection.TopDown)
                    {
                        x += child.DesiredSize.Width;
                        if (childIndex % childrenPerColumn == 0)
                        {
                            x = 0.0;
                            y += maxHeight;
                        }
                    }
                    else
                    {
                        y += maxHeight;
                        if (childIndex % Columns == 0)
                        {
                            y = 0.0;
                            //x += child.DesiredSize.Width;
                            x += _subColAlignWidths[childIndex/Columns - 1];
                        }
                    }
                }
            }
            return finalSize;
        }
        #endregion
    }
```

now, you can do the following.. 

```
                <Setter
                    Property="ItemsPanel">
                    <Setter.Value>
                        <ItemsPanelTemplate>
                            <controls:ColumnarPanel
                                Columns="2"
                                ColumnFillDirection="LeftRight"
                                HorizontalAlignment="Center"
                                IsItemsHost="True"
                                Orientation="Vertical"
                                FlowDirection="LeftToRight"
                                UseLayoutRounding="True"
                                Background="{DynamicResource DefaultBackgroundBrush}"
                                Width="{Binding Path=ActualWidth, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type ScrollContentPresenter}}}">
                            </controls:ColumnarPanel>
                        </ItemsPanelTemplate>
                    </Setter.Value>
                </Setter>
```


Later, I enhanced it to be the following. 

```
using System;
using System.Windows;
using System.Windows.Controls;

namespace Controls
{
    public enum ColumnFillDirection
    {
        /// <summary>
        /// Fill Items in the ColumnarPanel top-down (e.g. r0c0, r1c0, ..., rnc0, r1c0, .. rncn)
        /// </summary>
        TopDown,

        /// <summary>
        /// Fill items in the ColumnarPanel from Left to right (e.g. r0c0, r0c1, ... r0cn, r1c0,.. rncn)
        /// </summary>
        LeftRight,
    }

    /// <summary>
    /// Columnar Panel
    /// </summary>
    public class ColumnarPanel : Panel
    {
        #region Dependency Property Keys

        public static readonly DependencyProperty OrientationProperty =
            DependencyProperty.Register("Orientation", typeof(Orientation), typeof(ColumnarPanel), new FrameworkPropertyMetadata(Orientation.Vertical, FrameworkPropertyMetadataOptions.AffectsArrange | FrameworkPropertyMetadataOptions.AffectsMeasure));

        public static readonly DependencyProperty ColumnsProperty =
            DependencyProperty.Register("Columns", typeof(int), typeof(ColumnarPanel), new FrameworkPropertyMetadata(default(int), FrameworkPropertyMetadataOptions.AffectsArrange | FrameworkPropertyMetadataOptions.AffectsMeasure));

        public static readonly DependencyProperty ColumnFillDirectionProperty =
            DependencyProperty.Register("ColumnFillDirection", typeof(ColumnFillDirection), typeof(ColumnarPanel), new FrameworkPropertyMetadata(ColumnFillDirection.TopDown, FrameworkPropertyMetadataOptions.AffectsMeasure | FrameworkPropertyMetadataOptions.AffectsArrange));
        #endregion
        
        #region Fileds
        private double _maxWidth = 0.0;
        private double _maxHeight = 0.0;
        private Size[,] _fieldSizes;
        #endregion

        #region Type Initializer 

        static ColumnarPanel()
        {
            FlowDirectionProperty.AddOwner(typeof(ColumnarPanel));
        }

        #endregion

        #region Properties
        public Orientation Orientation
        {
            get { return (Orientation)GetValue(OrientationProperty); }
            set { SetValue(OrientationProperty, value); }
        }

        public int Columns
        {
            get { return (int)GetValue(ColumnsProperty); }
            set { SetValue(ColumnsProperty, value); }
        }

        public ColumnFillDirection ColumnFillDirection
        {
            get { return (ColumnFillDirection)GetValue(ColumnFillDirectionProperty); }
            set { SetValue(ColumnFillDirectionProperty, value); }
        }
        #endregion

        #region Overrides (Layout)
        protected override Size MeasureOverride(Size availableSize)
        {
            Size desiredSize = new Size(0.0, 0.0);
            int childCount = InternalChildren.Count;
            int childrenPerColumn = (int)Math.Ceiling((double)childCount / Columns);
            int childIndex = 0;
            _fieldSizes = new Size[Columns, childrenPerColumn];

            foreach (UIElement child in InternalChildren)
            {
                if (child != null)
                {
                    child.Measure(availableSize);
                    _fieldSizes[childIndex / childrenPerColumn, childIndex % childrenPerColumn] = child.DesiredSize;
                    childIndex++;
                }
            }

            if (Orientation == Orientation.Vertical)
            {
                var width = 0.0;
                for (int i = 0; i < Columns; i++)
                {
                    for (int j = 0; j < childrenPerColumn; j++)
                    {
                        width = _fieldSizes[i, j].Width > width ? _fieldSizes[i, j].Width : width;
                    }
                }

                _maxWidth = width;
                desiredSize.Width = width * Columns;
            }
            else
            {
                var height = 0.0;
                for (int i = 0; i < Columns; i++)
                {
                    for (int j = 0; j < childrenPerColumn; j++)
                    {
                        height = _fieldSizes[i, j].Height > height ? _fieldSizes[i, j].Height : height;
                    }
                }

                _maxHeight = height;
                desiredSize.Height = height * Columns;
            }

            for (int i = 0; i < childrenPerColumn; i++)
            {
                double dimension = 0.0;
                for (int j = 0; j < Columns; j++)
                {
                    var colIdx = ColumnFillDirection == ColumnFillDirection.TopDown
                                     ? j
                                     : ((i  * Columns) + j) / childrenPerColumn;
                    var rowidx = ColumnFillDirection == ColumnFillDirection.TopDown
                                     ? i
                                     : ((i * Columns) + j) % childrenPerColumn;

                    if (Orientation == Orientation.Vertical)
                    {
                        if (_fieldSizes[colIdx, rowidx].Height > dimension)
                        {
                            dimension = _fieldSizes[colIdx, rowidx].Height;
                        }
                    }
                    else
                    {
                        if (_fieldSizes[colIdx, rowidx].Width > dimension)
                        {
                            dimension = _fieldSizes[colIdx, rowidx].Width;
                        }
                    }
                }

                if (Orientation == Orientation.Vertical)
                {
                    desiredSize.Height += dimension;
                }
                else
                {
                    desiredSize.Width += dimension;
                }
            }

            return desiredSize;
        }

        protected override Size ArrangeOverride(Size finalSize)
        {
            int childCount = InternalChildren.Count;
            int childrenPerColumn = (int)Math.Ceiling((double)childCount / Columns);
            int childIndex = 0;
            double x = 0.0;
            double y = 0.0;

            double maxWidth = finalSize.Width / Columns > _maxWidth ? finalSize.Width / Columns : _maxWidth;
            double maxHeight = finalSize.Height / Columns > _maxHeight ? finalSize.Height / Columns : _maxHeight;

            foreach (UIElement child in InternalChildren)
            {
                Size size;

                var dimension = 0.0;
                int i = ColumnFillDirection == ColumnFillDirection.TopDown ? childIndex % childrenPerColumn : childIndex / Columns;
                for (int j = 0; j < Columns; j++)
                {
                    var colIdx = ColumnFillDirection == ColumnFillDirection.TopDown
                                     ? j
                                     : ((i * Columns) + j) / childrenPerColumn;
                    var rowidx = ColumnFillDirection == ColumnFillDirection.TopDown
                                     ? i
                                     : ((i * Columns) + j) % childrenPerColumn;

                    if (Orientation == Orientation.Vertical)
                    {
                        if (_fieldSizes[colIdx, rowidx].Height > dimension)
                        {
                            dimension = _fieldSizes[colIdx, rowidx].Height;
                        }
                    }
                    else
                    {
                        if (_fieldSizes[colIdx, rowidx].Width > dimension)
                        {
                            dimension = _fieldSizes[colIdx, rowidx].Width;
                        }
                    }
                }

                if (Orientation == Orientation.Vertical)
                {
                    size = new Size(maxWidth, dimension);
                }
                else
                {
                    size = new Size(dimension, maxHeight);
                }

                child.Arrange(new Rect(new Point(x, y), size));

                childIndex++;
                if (Orientation == Orientation.Vertical)
                {
                    if (ColumnFillDirection == ColumnFillDirection.TopDown)
                    {
                        y += dimension;
                        if (childIndex % childrenPerColumn == 0)
                        {
                            y = 0.0;
                            x += maxWidth;
                        }
                    }
                    else
                    {
                        x += maxWidth;
                        if (childIndex % Columns == 0)
                        {
                            x = 0.0;
                            y += dimension;
                        }
                    }
                }
                else
                {
                    if (ColumnFillDirection == ColumnFillDirection.TopDown)
                    {
                        x += dimension;
                        if (childIndex % childrenPerColumn == 0)
                        {
                            x = 0.0;
                            y += maxHeight;
                        }
                    }
                    else
                    {
                        y += maxHeight;
                        if (childIndex % Columns == 0)
                        {
                            y = 0.0;
                            x += dimension;
                        }
                    }
                }
            }

            return finalSize;
        }
        #endregion
    }
}

```


## Problems with binding to Window Height and Width

http://stackoverflow.com/questions/2673600/problems-with-binding-to-window-height-and-width


## Window Postion Extension 

```
using System;
using System.ComponentModel;
using System.Windows;
using System.Windows.Media;

namespace Desktop.Organizer
{
    public enum HorizontalPlacement
    {
        LeftInside,
        LeftOutside,
        RightInside,
        RightOutside,
        Center,
        Stretch,
    }

    public enum VerticalPlacement
    {
        TopInside,
        TopOutside,
        BottomInside,
        BottomOutside,
        Center,
        Stretch,
    }


    /// <summary>
    /// Extension methods for popups
    /// </summary>
    public static class PopupExtensions
    {
        #region Attached UnAdhere Action

        private static readonly DependencyProperty UnAdhereActionProperty =
            DependencyProperty.RegisterAttached("UnAdhereAction", typeof (Action), typeof (PopupExtensions), new PropertyMetadata(default(Action)));

        private static void SetUnAdhereAction(UIElement element, Action value)
        {
            element.SetValue(UnAdhereActionProperty, value);
        }

        private static Action GetUnAdhereAction(UIElement element)
        {
            return (Action) element.GetValue(UnAdhereActionProperty);
        }

        #endregion

        /// <summary>
        /// Move a window to the inside of a target element.
        /// Set source.Margin to adjust offset.
        /// </summary>
        /// <param name="source">the source window</param>
        /// <param name="target">the target element to move to</param>
        /// <param name="horizontalPlacement">horizontal placement to the target. Set source.Margin to adjust offset</param>
        /// <param name="verticalPlacement">vertical placement to the target. Set source.Margin to adjust offset</param>
        public static void MoveTo(this Window source, FrameworkElement target, 
            HorizontalPlacement horizontalPlacement = HorizontalPlacement.LeftInside, 
            VerticalPlacement verticalPlacement = VerticalPlacement.TopInside)
        {
            if(!target.IsVisible)
                return;

            var topLeftPointToScreen = target.PointToScreen(new Point(0, 0));
            var targetLeft = (int)topLeftPointToScreen.X;
            var targetRight = (int)(targetLeft + target.ActualWidth);
            var targetTop = (int)topLeftPointToScreen.Y;
            var targetBottom = (int)(targetTop + target.ActualHeight);

            var leftMargin = source.Margin.Left;
            var rightMargin = source.Margin.Right;
            var topMargin = source.Margin.Top;
            var bottomMargin = source.Margin.Bottom;

            switch (horizontalPlacement)
            {
                case HorizontalPlacement.LeftInside:
                    source.Left = targetLeft + leftMargin;
                    break;
                case HorizontalPlacement.LeftOutside:
                    source.Left = targetLeft - rightMargin - source.ActualWidth;
                    break;
                case HorizontalPlacement.RightInside:
                    source.Left = targetRight - rightMargin - source.ActualWidth;
                    break;
                case HorizontalPlacement.RightOutside:
                    source.Left = targetRight + leftMargin;
                    break;
                case HorizontalPlacement.Center:
                    source.Left = ((targetLeft + leftMargin) + (targetRight - rightMargin) - source.ActualWidth)/2;
                    break;
                case HorizontalPlacement.Stretch:
                    source.Width = target.ActualWidth - rightMargin - leftMargin;
                    source.Left = targetLeft + leftMargin;
                    break;
                default:
                    throw new ArgumentOutOfRangeException("horizontalPlacement");
            }

            switch (verticalPlacement)
            {
                case VerticalPlacement.TopInside:
                    source.Top = targetTop + topMargin;
                    break;
                case VerticalPlacement.TopOutside:
                    source.Top = targetTop - bottomMargin - source.ActualHeight;
                    break;
                case VerticalPlacement.BottomInside:
                    source.Top = targetBottom - bottomMargin - source.ActualHeight;
                    break;
                case VerticalPlacement.BottomOutside:
                    source.Top = targetBottom + topMargin;
                    break;
                case VerticalPlacement.Center:
                    source.Top = ((targetTop + topMargin) + (targetBottom - bottomMargin) - source.ActualHeight) / 2;
                    break;
                case VerticalPlacement.Stretch:
                    source.Height = target.ActualHeight - topMargin - bottomMargin;
                    source.Top = targetTop + topMargin;
                    break;
                default:
                    throw new ArgumentOutOfRangeException("verticalPlacement");
            }
        }

        /// <summary>
        /// This helps to make the source window look like a popup of the target window.
        /// Automatically unAdhere the previous window when executed again.
        /// Set source.Margin to adjust offset.
        /// </summary>
        /// <param name="source">the source window</param>
        /// <param name="target">the target element to be adhered to</param>
        /// <param name="horizontalPlacement">horizontal placement to the target. Set source.Margin to adjust offset</param>
        /// <param name="verticalPlacement">vertical placement to the target. Set source.Margin to adjust offset</param>
        /// <returns>let you undo the adhere</returns>
        public static void AdhereTo(this Window source, FrameworkElement target,
            HorizontalPlacement horizontalPlacement = HorizontalPlacement.LeftInside,
            VerticalPlacement verticalPlacement = VerticalPlacement.TopInside)
        {
            Action updatePosition = () => MoveTo(source, target, horizontalPlacement, verticalPlacement);
            AdhereTo(source, target, updatePosition);
        }

        /// <summary>
        /// This helps to make the source window look like a popup of the target window.
        /// You can "unAdhere" by executing the return IDisposable
        /// </summary>
        /// <param name="source">the source window</param>
        /// <param name="target">the target window to be adhered to</param>
        /// <param name="updatePosition">action to keep relative positions for source and target</param>
        /// <returns>let you undo the adhere</returns>
        private static void AdhereTo(this Window source, FrameworkElement target, Action updatePosition)
        {
            var targetWindow = Window.GetWindow(target);
            if (targetWindow == null)
                throw new Exception(string.Format("Cannot find window for: {0}", target.ToString()));
            
            source.UnAdhere();
            updatePosition();

            EventHandler layoutUpdatedHandler = (sender, args) => updatePosition();
            EventHandler locationChangedHandler = (sender, args) => updatePosition();
            SizeChangedEventHandler sizeChangedHandler = (sender, args) => updatePosition();
            EventHandler targetCloseHandler = (sender, args) => source.Close();

            target.LayoutUpdated += layoutUpdatedHandler;
            targetWindow.LocationChanged += locationChangedHandler;
            targetWindow.SizeChanged += sizeChangedHandler;
            targetWindow.Closed += targetCloseHandler;

            var descriptor = DependencyPropertyDescriptor.FromProperty(FrameworkElement.MarginProperty, typeof(Window));
            EventHandler sourceMarginChangedHandler = (sender, args) => updatePosition();

            EventHandler sourceLayoutUpdatedHandler = (sender, args) => updatePosition();
            EventHandler cleanUpHandler = null;
            cleanUpHandler = (sender, args) =>
            {
                target.LayoutUpdated -= layoutUpdatedHandler;
                targetWindow.LocationChanged -= locationChangedHandler;
                targetWindow.SizeChanged -= sizeChangedHandler;
                targetWindow.Closed -= targetCloseHandler;

                descriptor.RemoveValueChanged(source, sourceMarginChangedHandler);
                source.LayoutUpdated -= sourceLayoutUpdatedHandler;
                source.Closed -= cleanUpHandler;
            };

            descriptor.AddValueChanged(source, sourceMarginChangedHandler);
            source.LayoutUpdated += sourceLayoutUpdatedHandler;
            source.Closed += cleanUpHandler;
            targetWindow.EnsureHandle();
            source.Owner = targetWindow;

            SetUnAdhereAction(source, () => cleanUpHandler(null, EventArgs.Empty));
        }

        /// <summary>
        /// Undo "AdhereTo"
        /// </summary>
        /// <param name="source"></param>
        public static void UnAdhere(this Window source)
        {
            var action = GetUnAdhereAction(source);
            if (action != null)
                action();
        }

        /// <summary>
        /// Make a window look like popup
        /// </summary>
        /// <param name="window"></param>
        public static void ApplyPopupStyle(this Window window)
        {
            window.AllowsTransparency = true;
            window.Background = new SolidColorBrush(Colors.Transparent);
            window.BorderThickness = new Thickness(0);
            window.ShowInTaskbar = false;
            window.WindowStyle = WindowStyle.None;
            window.HideFromTaskList();
        }
    }
}
```

## Catch all exception in C#


While sometimes you might want to capture all exceptions, for the purpose of logging or auditing. 

you can do the following


Or you can do the following
```
        private void RestoreLayout(object sender, EventArgs e)
        {

            _restoringLayout = true;
            try
            {
                byte[] byteArray = Encoding.Default.GetBytes(Layout);

                using (var stream = new MemoryStream(byteArray, 0, byteArray.Length))
                {
                    AssociatedObject.RestoreLayoutFromStream(stream);
                }
            }
            catch (Exception)
            {
                Log.WarnFormat(
                    "Failed to restore Layout! Layout Name: {0}. LayoutXml may be corrupted!\nLayoutXml=\n{1}",
                    string.IsNullOrEmpty(LayoutName) ? "{unknown}" : LayoutName,
                    Layout);
                throw;
            }

            _restoringLayout = false;
        }

```

Or you can do the following. 

```
        private void RestoreLayout(object sender, EventArgs e)
        {
            _restoringLayout = true;
            try
            {
                byte[] byteArray = Encoding.Default.GetBytes(Layout);

                using (var stream = new MemoryStream(byteArray, 0, byteArray.Length))
                {
                    AssociatedObject.RestoreLayoutFromStream(stream);
                }
            }
            catch
            {
                Log.WarnFormat(
                    "Failed to restore Layout! Layout Name: {0}. LayoutXml may be corrupted!\nLayoutXml=\n{1}",
                    string.IsNullOrEmpty(LayoutName) ? "{unknown}" : LayoutName,
                    Layout);
                throw;
            }

            _restoringLayout = false;
        }
```


## Best Practices No. 5: Detecting .NET application memory leaks

References:

[detecting_net_application_memory_leask]: http://www.codeproject.com/Articles/42721/Best-Practices-No-Detecting-NET-application-memo
[Best Practices No. 5: Detecting .NET application memory leaks][detecting_net_application_memory_leask]

## Coerce values
I know this has been raised many a time, while this is not yet resolved, the problem is that we don't have a very solid understanding of the problem that we are facing... 

> The following example calls CoerceValue within a PropertyChangedCallback implementation that is used as the PropertyChangedCallback for a different dependency properties on the same class. This is a common pattern for introducing true value dependencies between dependency properties.

```
private static void OnCurrentReadingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
{
  d.CoerceValue(MinReadingProperty);
  d.CoerceValue(MaxReadingProperty);
}
```

Let's take some more example and see  , in Microsoft Window implementation, there is a CoerceTop coerce callback. 

the DependencyProperty is registered as follow. 

```
TopProperty = Canvas.TopProperty.AddOwner(typeof(Window), new FrameworkPropertyMetadata((double) 1.0 / (double) 0.0, new PropertyChangedCallback(Window._OnTopChanged), new CoerceValueCallback(Window.CoerceTop)));

```

the callback is called like the following 

```
    private static void _OnTopChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        Window window = d as Window;
        if (window._updateHwndLocation)
        {
            window.OnTopChanged((double) e.NewValue);
        }
    }

```

and the OnTopChagned code will handles the values.

```
private void OnTopChanged(double newTop)
{
    if (!this.IsSourceWindowNull && !this.IsCompositionTargetInvalid)
    {
        if (!DoubleUtil.IsNaN(newTop))
        {
            if (this.WindowState == WindowState.Normal)
            {
                Invariant.Assert(!double.IsNaN(this._actualLeft), "_actualLeft cannot be NaN after show");
                this.UpdateHwndPositionOnTopLeftChange(double.IsNaN(this.Left) ? this._actualLeft : this.Left, newTop);
            }
            else
            {
                this.UpdateHwndRestoreBounds(newTop, BoundsSpecified.Top);
            }
        }
    }
    else
    {
        this._actualTop = newTop;
    }
}
```

while the OnTopChanged check to see the status of the window, if it is hidden/minimized or Normal window state. 

```
  private void OnTopChanged(double newTop)
{
    if (!this.IsSourceWindowNull && !this.IsCompositionTargetInvalid)
    {
        if (!DoubleUtil.IsNaN(newTop))
        {
            if (this.WindowState == WindowState.Normal)
            {
                Invariant.Assert(!double.IsNaN(this._actualLeft), "_actualLeft cannot be NaN after show");
                this.UpdateHwndPositionOnTopLeftChange(double.IsNaN(this.Left) ? this._actualLeft : this.Left, newTop);
            }
            else
            {
                this.UpdateHwndRestoreBounds(newTop, BoundsSpecified.Top);
            }
        }
    }
    else
    {
        this._actualTop = newTop;
    }
}
``` 

after all this change notification chain, if we want to get a valid value on the Top, we might go through to consolidate properties that are related to Top and might affect by Top of affected Top...

```
    private static object CoerceTop(DependencyObject d, object value)
    {
        Window window = d as Window;
        window.VerifyApiSupported();
        double length = (double) value;
        ValidateTopLeft(length);
        if (!window.IsSourceWindowNull && !window.IsCompositionTargetInvalid)
        {
            if (double.IsNaN(length))
            {
                return window._actualTop;
            }
            if ((window.WindowState == WindowState.Normal) && (window._updateStartupLocation && (window.WindowStartupLocation != WindowStartupLocation.Manual)))
            {
                return window._actualTop;
            }
        }
        return value;
    }
```

References

[dependencyobject_coercevalue_method]: http://msdn.microsoft.com/en-us/library/system.windows.dependencyobject.coercevalue.aspx
[DependencyObject.CoerceValue Method][dependencyobject_coercevalue_method]



## the DockLayoutManagerBehavior

Recently I found there is a Race condition in regarding to the DockLayoutManagerBahavior and the Layout that it binds to.. 

the problem with that it that the Layout has one "Documents" collection, and that collection will be created when the Layout is switched in (that is activated)

however, the old code does this


```
        private void RestoreLayout(object sender, EventArgs e)
        {
            if (_restoringLayout)
            {
                return;
            }
            _restoringLayout = true;
            byte[] byteArray = Encoding.Default.GetBytes(Layout);
            using (var stream = new MemoryStream(byteArray, 0, byteArray.Length))
            {
                AssociatedObject.RestoreLayoutFromStream(stream);
            }
            _restoringLayout = false;
        }
```

Simply as that. 

However, the problems is that the Documents collection is not created until it has been swapped in . the code is as follow. 

```
        private void LoadsDocumentsIfNotLoaded(LayoutViewModel layout)
        {
            if (layout != null)
            {
                if (!layout.LoadComplete)
                {
                    layout.CreateDocuments();
                    layout.LoadComplete = true;
                    layout.OnRestoreLayout();
                }

                if (!layout.IsConnected)
                {
                    layout.IsConnected = true;
                }
            }
        }
```

if you try to restore a layout when the layout itself is not loaded, then you would be met with some errors. the real problem is not the errors, but is that the errors does not happen deterministics. 

which is quite irksome. 

the Behavior also has one AssociatedObjectLoaded method, which has the following. 


```
        private void AssociatedObjectLoaded(object sender, RoutedEventArgs e)
        {
            if (AssociatedObject.DataContext is ILayout)
            {
                var x = AssociatedObject.DataContext as ILayout;
                x.UpdateLayout += UpdateLayout;
                x.RestoreLayout += RestoreLayout;
                x.NotifyLayoutManagerLoaded();

                if (!string.IsNullOrEmpty(Layout))
                {
                    RestoreLayout(null, null);
                }
            }
        }
```

this is to ensure that the when a DockLayoutManager is loaded and the Layout is not null, it calls the RestoreLayout to restore it.

the fix is to 
1. enhance the log report
2. check on boundary conditions, such as LoadComplete is false, Layout is null or empty, and etc...

the code now is 

```
using System;
using System.IO;
using System.Reflection;
using System.Text;
using System.Windows;
using System.Windows.Interactivity;
using DevExpress.Xpf.Docking;
using DevExpress.Xpf.Docking.Base;
using log4net;

namespace Behaviors
{
    /// <summary>
    /// Behaviour to get and set the document layouts.
    /// </summary>
    public class DockLayoutManagerBehaviour : Behavior<DockLayoutManager>
    {
        #region Static Fields
        public static readonly DependencyProperty LayoutProperty = DependencyProperty.Register(
            "Layout",
            typeof(string),
            typeof(DockLayoutManagerBehaviour),
            new PropertyMetadata(default(string)));

        public static readonly DependencyProperty SelectedDocumentProperty =
            DependencyProperty.Register(
                "SelectedDocument", typeof(object), typeof(DockLayoutManagerBehaviour), new PropertyMetadata(null));

        public static readonly DependencyProperty LayoutNameProperty =
            DependencyProperty.Register(
                "LayoutName", typeof(string), typeof(DockLayoutManagerBehaviour), new PropertyMetadata(default(string)));

        public static readonly DependencyProperty LayoutLoadCompleteProperty =
            DependencyProperty.Register(
                "LayoutLoadComplete", typeof(bool), typeof(DockLayoutManagerBehaviour), new PropertyMetadata(default(bool)));

        #endregion

        #region Static Fields (Logging)
        private static readonly ILog Log = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);
        #endregion

        #region Fields

        private bool _restoringLayout;
        private bool _isCleanedUp;

        #endregion

        #region Public Properties

        /// <summary>
        /// Gets or sets the layout
        /// </summary>
        public string Layout
        {
            get
            {
                return (string)GetValue(LayoutProperty);
            }

            set
            {
                SetValue(LayoutProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the selected Document
        /// </summary>
        public object SelectedDocument
        {
            get
            {
                return GetValue(SelectedDocumentProperty);
            }

            set
            {
                SetValue(SelectedDocumentProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the Active Layout's name
        /// </summary>
        public string LayoutName
        {
            get
            {
                return (string)GetValue(LayoutNameProperty);
            }

            set
            {
                SetValue(LayoutNameProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the layout has Loaded (Documents collection has been created)
        /// </summary>
        /// <remarks>
        /// <para>
        /// With introducing the Cache Manager, Layout might be loaded into the Cache Manager uninitialized (the Documents collection are not created) for 
        /// performance boost.
        /// </para>
        /// <para>
        /// class <see cref="DockLayoutManagerBehaviour"/> is supposed to be a general Dock Layout Manager extension that shall works with no assumption on the relative 
        /// initialization order of the Layout View Model and the Views that it attaches to. When <see cref="DockLayoutManagerBehaviour"/>'s associated object 
        /// is loaded, it tries to Restore Layout if it find the Layout property is set on startup. However, if the Layout is not fully initialized 
        /// (e.g. the Documents collection is not created) at that time, the DevExpress Dock Layout Manager is not be able to cope with arranging items which are not 
        /// created and it throws up.
        /// </para>
        /// <para>
        /// This Flag is to indicate whether the layout is in the position to be rearranged by the DockLayoutManager runtime by serialize/deserialize the Layout xml.
        /// </para>
        /// </remarks>
        public bool LayoutLoadComplete
        {
            get
            {
                return (bool)GetValue(LayoutLoadCompleteProperty);
            }

            set
            {
                SetValue(LayoutLoadCompleteProperty, value);
            }
        }
        #endregion

        #region Public Methods and Operators

        public static void LoadSettings(DockLayoutManager manager, Stream stream)
        {
            manager.RestoreLayoutFromStream(stream);
        }

        public static void SaveSettings(DockLayoutManager manager, Stream stream)
        {
            manager.SaveLayoutToStream(stream);
        }

        #endregion

        #region Protected Methods

        protected override void OnAttached()
        {
            base.OnAttached();

            AssociatedObject.Loaded += AssociatedObjectLoaded;
            AssociatedObject.Unloaded += AssociatedObjectUnloaded;

            AssociatedObject.DockItemClosing += AssociatedObjectDockItemClosing;
            AssociatedObject.DockItemActivated += AssociatedObjectDockItemActivated;

            AssociatedObject.DockOperationCompleted += AssociatedObjectDockOperationCompleted;
            AssociatedObject.DockItemRestored += AssociatedObjectDockItemRestored;
            AssociatedObject.DockItemHidden += AssociatedObjectDockItemHidden;
            AssociatedObject.DockItemDragging += AssociatedObjectDockItemDragging;
            AssociatedObject.LayoutItemSizeChanged += AssociatedObjectLayoutItemSizeChanged;
        }
        #endregion

        #region Private Methods
        private void AssociatedObjectDockItemActivated(object sender, DockItemActivatedEventArgs e)
        {
            if (e.Item != null)
            {
                SetValue(SelectedDocumentProperty, e.Item.DataContext);
            }
        }

        private void AssociatedObjectDockItemClosing(object sender, ItemCancelEventArgs e)
        {
            e.Cancel = true;
        }

        private void AssociatedObjectDockItemHidden(object sender, ItemEventArgs e)
        {
            NotifyLayoutChanged();
        }

        private void AssociatedObjectDockItemRestored(object sender, ItemEventArgs e)
        {
            NotifyLayoutChanged();
        }

        private void AssociatedObjectDockOperationCompleted(object sender, DockOperationCompletedEventArgs e)
        {
            NotifyLayoutChanged();
        }

        private void AssociatedObjectDockItemDragging(object sender, DockItemDraggingEventArgs e)
        {
            NotifyLayoutChanged();
        }

        private void AssociatedObjectLayoutItemSizeChanged(object sender, LayoutItemSizeChangedEventArgs e)
        {
            NotifyLayoutChanged();
        }

        private void AssociatedObjectLoaded(object sender, RoutedEventArgs e)
        {
            if (AssociatedObject.DataContext is ILayout)
            {
                var x = AssociatedObject.DataContext as ILayout;
                x.UpdateLayout += UpdateLayout;
                x.RestoreLayout += RestoreLayout;
                x.NotifyLayoutManagerLoaded();

                if (!string.IsNullOrEmpty(Layout) && LayoutLoadComplete)
                {
                    RestoreLayout(null, null);
                }
            }
        }

        private void AssociatedObjectUnloaded(object sender, RoutedEventArgs e)
        {
            Cleanup();
        }

        private void Cleanup()
        {
            if (!_isCleanedUp)
            {
                _isCleanedUp = true;

                AssociatedObject.Loaded -= AssociatedObjectLoaded;
                AssociatedObject.Unloaded -= AssociatedObjectUnloaded;
                AssociatedObject.DockItemClosing -= AssociatedObjectDockItemClosing;
                AssociatedObject.DockItemActivated -= AssociatedObjectDockItemActivated;

                AssociatedObject.DockOperationCompleted -= AssociatedObjectDockOperationCompleted;
                AssociatedObject.DockItemRestored -= AssociatedObjectDockItemRestored;
                AssociatedObject.DockItemHidden -= AssociatedObjectDockItemHidden;
                AssociatedObject.DockItemDragging -= AssociatedObjectDockItemDragging;
                AssociatedObject.LayoutItemSizeChanged -= AssociatedObjectLayoutItemSizeChanged;

                var layout = AssociatedObject.DataContext as ILayout;
                if (layout != null)
                {
                    layout.UpdateLayout -= UpdateLayout;
                    layout.RestoreLayout -= RestoreLayout;
                }
            }
        }

        private void NotifyAssociatedLayoutChanged()
        {
            if (AssociatedObject == null)
            {
                return;
            }

            ILayout x = AssociatedObject.DataContext as ILayout;
            if (x != null)
            {
                x.NotifyLayoutChanged();
            }
        }

        private void RestoreLayout(object sender, EventArgs e)
        {
            if (_restoringLayout)
            {
                return;
            }

            if (!LayoutLoadComplete)
            {
                Log.WarnFormat(
                    "Layout {0} has not complete loading! Skip Restoring Layouts", 
                    LayoutName);
                return;
            }

            if (string.IsNullOrEmpty(Layout))
            {
                Log.WarnFormat(
                    "LayoutXml is null or empty! Layout Name: {0}. Skip restoring layout!", 
                    LayoutName);
                return;
            }

            _restoringLayout = true;
            try
            {
                byte[] byteArray = Encoding.Default.GetBytes(Layout);

                using (var stream = new MemoryStream(byteArray, 0, byteArray.Length))
                {
                    AssociatedObject.RestoreLayoutFromStream(stream);
                }
            }
            catch (Exception ex)
            {
                Log.WarnFormat(
                    "Failed to restore Layout! Layout Name: {0}. LayoutXml may be corrupted!\nLayoutXml=\n{1}",
                    LayoutName,
                    Layout);
                throw new InvalidOperationException("Failed to restore Layout with corrupted Layout", ex);
            }
            finally
            {
                _restoringLayout = false;
            }
        }

        private void UpdateLayout(object sender, EventArgs e)
        {
            try
            {
                using (var stream = new MemoryStream())
                {
                    AssociatedObject.SaveLayoutToStream(stream);
                    stream.Position = 0;
                    Layout = new StreamReader(stream).ReadToEnd();
                }
            }
            catch (Exception ex)
            {
                Log.WarnFormat(
                    "Failed to Serialize Layout! Layout Name: {0}. Possibly due to previous Layout restoring error!",
                    LayoutName);
                throw new InvalidOperationException("Failed to serialize Layout", ex);
            }
        }

        private void NotifyLayoutChanged()
        {
            if (_restoringLayout)
            {
                return;
            }

            if (AssociatedObject.IsDisposing)
            {
                Cleanup();
                return;
            }

            NotifyAssociatedLayoutChanged();
        }
        #endregion
    }
}
```

## Memory Profiling tips and resources. 

Some counters used for detecting memory leak
谢谢~~ 好文， 我先试
OK
下面有个图表
要选择某个process得Private Bytes再配合着.NET CLR Memory中Bytes in all Heaps一起看

Investigating Memory Issues:  http://msdn.microsoft.com/en-us/magazine/cc163528.aspx 
Weak Event Patterns:  http://msdn.microsoft.com/en-us/library/aa970850.aspx 


[best_practices_no_5_detecting_dotnet_app_memory_leaks]: http://www.codeproject.com/Articles/42721/Best-Practices-No-Detecting-NET-application-memo#Usingprivatebytesperformancecounterstodetectmemoryleak
[best_practices_no_5_detecting_dotnet_app_memory_leaks][best_practices_no_5_detecting_dotnet_app_memory_leaks]
[Investigating Memory Issues](http://msdn.microsoft.com/en-us/magazine/cc163528.aspx )
[Weak Event Patterns]:  (http://msdn.microsoft.com/en-us/library/aa970850.aspx)

## Webkit and the Javascript implementation

While the Webit kis becoming the core of the google chrome implementation, we might want to take into the jacscript implementation on the webkit platform. 
Read the following materials: [JavaScriptCore, the WebKit JS implementation][javascript_core_the_webkit_js_implementation]

References:
[javascript_core_the_webkit_js_implementation]: http://wingolog.org/archives/2011/10/28/javascriptcore-the-webkit-js-implementation
[JavaScriptCore, the WebKit JS implementation][javascript_core_the_webkit_js_implementation]

## Row colors in Viewer UI , and how it works.

in the RepFlowNew, there is the TenorColour header, which shows row header TenorColour in different colour.  and how is that achieved.

first, in the "ModuleColors" 

`        public static readonly Color GoldPackForegroundColor = (Color)ColorConverter.ConvertFromString("#CE9923");`

this has been turned into a Brush, "ModuleBrushes.cs"

`        public static readonly Brush GoldPackForegroundBrush = ModuleColors.GoldPackForegroundColor.ToFrozenBrush();`

and it further goes to the converter, that goes to "FuturePackToBrushConverter".

it does the value 

```
    public class FuturePackToBrushConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value == null)
            {
                return ModuleBrushes.ForegroundBrush;
            }

            switch (value.ToString().ToLower())
            {
                case "white":
                    return ModuleBrushes.WhitePackForegroundBrush;
                case "red":
                    return ModuleBrushes.RedPackForegroundBrush;
                case "green":
                    return ModuleBrushes.GreenPackForegroundBrush;
                case "blue":
                    return ModuleBrushes.BluePackForegroundBrush;
                case "gold":
                    return ModuleBrushes.GoldPackForegroundBrush;

                ...
```

and in the HierarchyView.xaml, there is such resource declaration 

`                    <cnvt:FuturePackToBrushConverter x:Key="_futurePackForegroundConverter"/>`

and it was used in some PriceColumnTemplate, here it is  

```
                        <dxGrid:CellTemplateSelector.PriceColumnTemplate>
                            <DataTemplate>
                                <TextBlock
                                    Padding="2,0,2,0">
                                        <!-- ... -->
                                        <TextBlock.Style>
                                        <Style TargetType="{x:Type TextBlock}">
                                            <Style.Triggers>
                                                <DataTrigger
                                                    Binding="{Binding Path=Column, RelativeSource={RelativeSource AncestorType={x:Type dxg:CellContentPresenter}}, 
                                                        Converter={StaticResource _columnPropertyToValueConverter}, ConverterParameter=ApplyColourCoding}"
                                                    Value="True">
                                                    <Setter
                                                        Property="Foreground"
                                                        Value="{Binding Path=RowData.Row.ColumnColour, Converter={StaticResource _futurePackForegroundConverter}}">
                                                    </Setter>
                                                </DataTrigger>
                                            </Style.Triggers>
```

And if you dig into the code , we found the following "Your:App:Viewer:RulesProviderConfig", and it has the following. 

```
<root xmlns="http://www.app.com/your_org/core/sonic/1.1" type=".UI.DataAccess.Data.RuleDto" category="Your:App:Viewer:ReportConfig">
    <Rules type="list">
        <i model=".UI.Providers.Rules.PassThrough:1">
            <Columns type="list">
                <i model="Sonic.Tabular.ColumnMapping:1">
                    <InputColumnName value="Colour"/>
                    <OutputColumnName value="ColumnBorder"/>
                    <OutputColumnType type="type" value="string"/>
                </i>
                <i model="Sonic.Tabular.ColumnMapping:1">
                    <InputColumnName value="Colour"/>
                    <OutputColumnName value="ColumnColour"/>
                    <OutputColumnType type="type" value="string"/>
                </i>
            </Columns>
            <!-- ... -->
```

## to create an empty IEnumerable list 
```
public IEnumerable BoundsColumns { 
  get  { yield break; }
}
```
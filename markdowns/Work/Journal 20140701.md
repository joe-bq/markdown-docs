## GridControl.VisibleRowCount

the GridControl.VisibleRowCount is volatile, especially when the Grid is experiencing the regrouping and others.

where we have the followign code 

```
        private void DoSave(bool canSave = false)
        {
            bool saveSettings = !(_gridControl != null && _gridControl.VisibleRowCount == 0);

            var newCallCancellation = new CancellationTokenSource();
            Interlocked.Exchange(ref _cancellationTokenSource, newCallCancellation).Cancel();

            new DelayTask(new TimeSpan(0, 0, 1), _delayTasks)
                 .Task.ContinueWith(
                     t =>
                         {
                             if (saveSettings)
                             {
                                 SaveSettings(false, canSave);
                             }
                             else
                             {
                                 SyncSettings(false);
                             }
                         },
                     _cancellationTokenSource.Token,
                     TaskContinuationOptions.OnlyOnRanToCompletion,
                     _uiTaskSchedulerService.GetUITaskScheduler())
                 .LogTaskExceptionIfAny(Log);
        }
```

we decide whether or not to Save the settings, based on the GridControl is not null and the GridControl has more than 0 VisibleRowCount.

however, if we add some logs, what we would get from console woudl be 


VisibleRowCount = 86
VisibleRowCount = 86
VisibleRowCount = 86
VisibleRowCount = 0
VisibleRowCount = 0
VisibleRowCount = 0
VsibileRowCount = 8


while the relative order of the Log may not be right, but it shows a very basic idea that the when grouping, while the row is updating, you might be able to see the VisibleRowCount ranging from 0 (means it is doing a re-adding), to 86 (when no grouping is applied) to 8 (when the group is well done..)



## Move elements in ObservableCollection

Below is the code that does the synchronization between two elements.  the Code is as follow..


```
        private void LayoutPresentersChanged(object sender, NotifyCollectionChangedEventArgs args)
        {
            LayoutPresenter[] oldItems = null;
            LayoutPresenter[] newItems = null;

            switch (args.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    args.NewItems.Cast<LayoutPresenter>().Select(x => x.View).OfType<DataViewerLayoutView>().ForEach(
                        x => LayoutViews.Add(x));
                    break;
                case NotifyCollectionChangedAction.Move:
                    oldItems = args.OldItems.Cast<LayoutPresenter>().ToArray();

                    /*
                    for (int i = 0; i < oldItems.Length; i++)
                    {
                        var displace = args.NewStartingIndex > args.OldStartingIndex
                                           ? args.NewStartingIndex - args.OldStartingIndex
                                           : i;
                        var origin = args.NewStartingIndex > args.OldStartingIndex
                                         ? args.OldStartingIndex
                                         : args.OldStartingIndex + i;

                        LayoutViews.Move(origin, displace);
                    }
                    */
                    if (args.NewStartingIndex < args.OldStartingIndex)
                    {
                        for (int i = 0; i < oldItems.Length; i++)
                        {
                            LayoutViews.Move(args.OldStartingIndex + i, args.NewStartingIndex + i);
                        }
                    }
                    else
                    {
                        for (int i = oldItems.Length - 1; i >= 0; i--)
                        {
                            LayoutViews.Move(args.OldStartingIndex + i, args.NewStartingIndex + i);
                        }
                    }

                    break;
                case NotifyCollectionChangedAction.Remove:
                    args.OldItems.Cast<LayoutPresenter>().Select(x => x.View).OfType<DataViewerLayoutView>().ForEach(
                        x => LayoutViews.Remove(x));
                    break;
                case NotifyCollectionChangedAction.Replace:
                    oldItems = args.OldItems.Cast<LayoutPresenter>().ToArray();
                    newItems = args.OldItems.Cast<LayoutPresenter>().ToArray();
                    for (int i = oldItems.Length; i >= 0; i++)
                    {
                        LayoutViews[args.OldStartingIndex + i] = newItems[i].View as DataViewerLayoutView;
                    }

                    /*var zipped = args.OldItems
                                     .Cast<LayoutPresenter>()
                                     .Zip(
                                        args.NewItems.Cast<LayoutPresenter>(), 
                                        (old, @new) => new { Old = old.View as DataViewerLayoutView, New = @new.View as DataViewerLayoutView })
                                     .Where(x => x.Old != null);
                    zipped.ForEach(x =>
                                         {
                                             if (x.Old != null)
                                             {
                                                 var index = LayoutViews.IndexOf(x.Old);
                                                 if (index != -1)
                                                 {
                                                     LayoutViews.RemoveAt(index);
                                                     LayoutViews.Insert(index, x.New);
                                                 }
                                             }
                                         });
                    */
                    break;
                case NotifyCollectionChangedAction.Reset:
                    LayoutViews.Clear();
                    break;
            }
        }
```

things to be watchful is 

* when moving elements
* when Replace elements


when moving elements, we have to watch for hte direction in order to preserve the right order, you can either first determine the direction and then use for loops (upwards or downwards depensd on the situation) or you can determine the "origin" and the dsiplace when doing moving (for moving elements forward, you'd better do that with a loop count downwards, but you can also do that with a upward counts but each time in the loop the origin is fixed and the display is also fixed...) 

With Replace, things are easier, you can just do a for loop to to update each elements in place.. But you can also do a search and replace operation, which is significantly slower.

## CacheManager to stop previous active layouts.

You might be tempted to do the following, depends on whether the previous layouts is switched off, 

```
        private void ChangeLayout(LayoutViewModel layout, LayoutViewModel previous)
        {
            IsInChangingLayout = true;
            _busyIndicatorService.IsBusy = true;

            LayoutViewModel swappedOutItem;
            LoadIn(layout, out swappedOutItem);

            if (!_cacheManagerOption.AlwaysAvailable)
            {
                // If NOT keeps all layouts in Cache active, stops non-selected layouts
                Layouts.Except(new[] { layout }).Where(x => x.IsConnected).ForEach(
                    l =>
                        {
                            var lp = FirstPresenterOrDefault(layout);
                            StopLayout(lp);
                        });
            }
            else
            {
                // otherwise, 
                if (previous != null && previous != swappedOutItem)
                {
                    var previousPresenter = FirstPresenterOrDefault(previous);
                    StopLayout(previousPresenter);
                }
            }
            ...
}

```

However, there are some problem that previous might be part of the collection  

```
Layouts.Except(new[] { layout }).Where(x => x.IsConnected).ForEach(
```

## UserControl vs. DataTemplate

There are two issues that I have observed in a UserControl vs. DataTemplate scenario.

### the DataTemplate regenerating issues 

I found a rather nasty bug when the desktop theme changes, the layout has completely changed which positions all the panels side by side left-to-right.

the reason as according to the reporters, 

> When we looked into this previously, it came down to the desktop theme changing automatically overnight to update the computer’s background image (with times and dates in it). The top level view holding the docking manager was actually a data template that was being revisited when the view changed. I changed this to a true user control and the problem went away. (Note: This was only at the top level where the docking manager gets instantiated; all of the normal views are still created from data templates).

### the IsVisible and View Model with Datatemplate

while ViewModel with Data Template is handy, there are problems that associated with this mean, the problems being that if LayoutViewModel is not yet bind for views (that no views has yet generated on the view model, such as the ViewModel has a Visible property which by default is false). the WPF engine does something smart and lazy creates those views. 

I had such an situation where it is a Layout View Model which has a view collection, and there is behavior which takes care of restoring the arrangement of the views.

While when the views are really brought into front, the restoring of the views may not happens because the view is not yet created, and the view may not be able to be notified of the view model changes (such as new Views has been registered and etc..) thus it may miss creating of views. - whatever it is the net result is that I get an empty layout manager.

The above mentioned issues are two uncommon issues that I have recently encounterd, felt that it may help others with similar problems.

## Some test for Instance Switcher

there are some tasks that you can do to test the instance switcher. 

1. mark for a, b, c for EMEA, and select to Asia , mark d, and switch back to EMEA, you should see a, b, c
2. wait on data up, mark a, b, c on EMEA and then switch instance to Asia to see the data stopped and loads correctly
3. When views has override, the overrides shall be respected (per regions)
4. when users selects Books instead of Desks, it should not throw exceptios.

## DX (DevExpress) 14.1 the optimized mode

there is a light-weight, a.k.a the optimized mode, where there is a special edit (control), that is called  DevExpress.Xpf.Editors.InplaceBaseEdit, this new editor has replace the needs for defines multiple cell templates for different modes. As accordingo to the documentation, this isa  special lightweight editor that does not have a default visual tree.

> Setting in-place editors with the DataViewBase.CellTemplate property generates unoptimized editors. To use optimized editors, place a DevExpress.Xpf.Editors.InplaceBaseEdit editor with the Name property set to “PART_Editor” inside the cell template. With this approach, the editor settings are taken from the ColumnBase.EditSettings property of the GridColumn.

It was said that this can 

> default and provides a greatly improved scrolling performance and a reduced load time for hot starts after loading the first instance.

Though haven't digging into the code yet, but I guess that the olde way generates UI elements with the temlate (generator), on different mode, different UI elements might be created? and when it was creating, it generates a more convoluted visual tree...?

References
[optimized_mode]: https://documentation.devexpress.com/#WPF/CustomDocument17112
[Optimized Mode][optimized_mode]

## the DX or the Video card driver problem 

recently I found a very strange problem that occurred on the video driver.  

the promblem is that when I drag many views to the docked ones, sometimes it will throws up and the error messages that it has is as follow. 

```
2014-07-21T16:18:40.419702 [FATAL] {Thread: UI} ContentProvider: Dispatcher exception occurred on main thread.
System.OutOfMemoryException: Insufficient memory to continue the execution of the program.
   at System.Windows.Media.Composition.DUCE.Channel.SyncFlush()
   at System.Windows.Media.MediaContext.CompleteRender()
   at System.Windows.Interop.HwndTarget.OnResize()
   at System.Windows.Interop.HwndTarget.HandleMessage(WindowMessage msg, IntPtr wparam, IntPtr lparam)
   at System.Windows.Interop.HwndSource.HwndTargetFilterMessage(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean& handled)
   at MS.Win32.HwndWrapper.WndProc(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean& handled)
   at MS.Win32.HwndSubclass.DispatcherCallbackOperation(Object o)
   at System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Int32 numArgs)
   at MS.Internal.Threading.ExceptionFilterHelper.TryCatchWhen(Object source, Delegate method, Object args, Int32 numArgs, Delegate catchHandler)
2014-07-21T16:18:42.466577 [INFO ] {Thread: 11} CTX005.1.1: Received Response of type: application/xml;charset=UTF-8 (size = -1) in 3007 ms
2014-07-21T16:18:43.857202 [INFO ] {Thread:  9} CTX005.1.1: Received Response of type: application/xml;charset=UTF-8 (size = -1) in 3027 ms
2014-07-21T16:18:46.185327 [INFO ] {Thread: UI} Assembly ICSharpCode.SharpZipLib, Version=0.86.0.518, Culture=neutral, PublicKeyToken=1b03e6acf1164f73 added successfully
2014-07-21T16:18:47.013452 [FATAL] {Thread: UI} ContentProvider: Dispatcher exception occurred on main thread.
System.OutOfMemoryException: Insufficient memory to continue the execution of the program.
```

While i search on the internet, there points to somewhere like below. 
* [WPF Out Of Memory][wpf_out_of_memory]
* [OutOfMemoryException when opening RadWindow][outofmemoryexception_when_opening_radwindow]
* [OutOfMemoryException while trying to drag a window][outofmemory_exception_when_trying_to_drag_a_window]

while the reason points to the video car drivers. 

I tried the reproduce the problem with a Win-7 box, which has 

* dx11 
* video car driver 314.07

```
NVIDIA System Information report created on: 07/21/2014 16:53:40
System name: SHAWD4066

[Display]
Operating System:	Windows 7 Enterprise, 64-bit (Service Pack 1)
DirectX version:	11.0 
GPU processor:		NVS 300
Driver version:		314.07
Direct3D API version:	10.1
CUDA Cores:		16 
Core clock:		520 MHz 
Shader clock:		1230 MHz
Memory data rate:	1580 MHz
Memory interface:	64-bit 
Total available graphics memory:	4095 MB
Dedicated video memory:	512 MB DDR3
System video memory:	0 MB
Shared system memory:	3583 MB
Video BIOS version:	70.18.9F.00.0C
IRQ:			0
Bus:			PCI Express x16 Gen2
Device Id:		10DE 10D8 0862103C
Part Number:		1035 0500

[Components]

nvui.dll		8.17.13.1407		NVIDIA User Experience Driver Component
nvxdsync.exe		8.17.13.1407		NVIDIA User Experience Driver Component
nvxdplcy.dll		8.17.13.1407		NVIDIA User Experience Driver Component
nvxdbat.dll		8.17.13.1407		NVIDIA User Experience Driver Component
nvxdapix.dll		8.17.13.1407		NVIDIA User Experience Driver Component
NVCPL.DLL		8.17.13.1407		NVIDIA User Experience Driver Component
nvCplUI.exe		7.1.720.0		NVIDIA Control Panel
nvWSS.dll		6.14.13.1407		NVIDIA Workstation Server
nvViTvS.dll		6.14.13.1407		NVIDIA Video Server
NVMCTRAY.DLL		8.17.13.1407		NVIDIA Media Center Library
nvDispS.dll		6.14.13.1407		NVIDIA Display Server
NVCUDA.DLL		8.17.13.1407		NVIDIA CUDA 5.0.1 driver
nvGameS.dll		6.14.13.1407		NVIDIA 3D Settings Server

```

and my xp box is as follow. 

* dx 9
* driver is 271.05


```
NVIDIA System Information report created on: 07/21/2014 16:54:23
System name: SHAWD4071

[Display]
Operating System:	Microsoft Windows XP, 32-bit (Service Pack 3)
DirectX version:	9.0 
GPU processor:		NVS 300
Driver version:		271.05
DirectX support:	10.1
CUDA Cores:		16 
Core clock:		520 MHz 
Shader clock:		1230 MHz
Memory clock:		790 MHz (1580 MHz data rate) 
Memory interface:	64-bit 
Memory:			512 MB
Memory type:		DDR3
Video BIOS version:	70.18.9F.00.0C
IRQ:			16
Bus:			PCI Express x16

[Components]

NVCPL.DLL		6.14.12.7105		NVIDIA Compatible Windows 2000 Display driver, Version 271.05 
nvCplUIR.dll		3.6.752.0		NVIDIA Control Panel
nvCplUI.exe		3.6.752.0		NVIDIA Control Panel
nvWSSR.dll		6.14.12.7105		NVIDIA Workstation Server
nvWSS.dll		6.14.12.7105		NVIDIA Workstation Server
nvViTvSR.dll		6.14.12.7105		NVIDIA Video Server
nvViTvS.dll		6.14.12.7105		NVIDIA Video Server
nvMoblSR.dll		6.14.12.7105		NVIDIA Mobile Server
nvMoblS.dll		6.14.12.7105		NVIDIA Mobile Server
nvDispSR.dll		6.14.12.7105		NVIDIA Display Server
NVMCTRAY.DLL		6.14.12.7105		NVIDIA Media Center Library
NVOGLNT.DLL		6.14.12.7105		NVIDIA Compatible OpenGL ICD
nvDispS.dll		6.14.12.7105		NVIDIA Display Server
NV4_MINI.SYS		6.14.12.7105		NVIDIA Compatible Windows 2000 Miniport Driver, Version 271.05 
NV4_DISP.DLL		6.14.12.7105		NVIDIA Compatible Windows 2000 Display driver, Version 271.05 
NVCUDA.DLL		6.14.12.7105		NVIDIA CUDA 4.0.1 driver
nvGameSR.dll		6.14.12.7105		NVIDIA 3D Settings Server
nvGameS.dll		6.14.12.7105		NVIDIA 3D Settings Server

```

It is also explained in one of the article called "[WPF Render Thread Failures][wpf_render_thread_failures]", where 

> The simple answer is that the WPF render thread encountered some fatal error. There can be many causes of fatal errors on the render thread. Most of the time, a failure occurs when calling into DirectX/D3D, but can also occur due to a failed User32 or GDI call. There is no one root bug or issue for why these can occur, so there's no one specific "fix" that can be done to alleviate the problem. When WPF's render thread makes a call into another component; such as DirectX/D3D, User32, GDI32, etc. it checks the return value for success or failure. When a failure is detected, WPF "zombies" the render partition and notifies the UI thread of the failure the next time the two threads are synchronized. The render thread will attempt to map the failure it receives to an appropriate managed exception. For example, if the WPF render thread failed due to some out of memory condition, then it will map the failure to a System.OutOfMemoryException, and that would be the exception encountered on the UI thread. The render thread only synchronizes with the UI thread in a few locations, so the callstacks above are typically where you notice the problem, not where it actually occurred. The most common locations when they synchronize are when a window's settings are updated (size, position, etc.) or as a result of the UI thread handling a "channel" message from DirectX.

and why some common reasons for failure?

* Drivers/hardware
* windows XP and 2003 platforms.


when  WPF via DirectX , queries capability, the video driver might misreport its capability. Or "layered windows", the layered window implemenation is fragile on Windows XP. with a number of bugs that impacted WPF significantly (the layered window feature is enabled when you have Window.AllowsTransparency or Popup.AllowsTransparency properties in WPF.

> Historically speaking, the most common bucket of WPF render thread failures was associated with video hardware or driver problems. This is particularly true on the Windows XP and 2003 platforms, where the video hardware/drivers in use (particularly in enterprise environments) weren't up to par for hardware rendering. When WPF, via DirectX, queried the video driver for capabilities, the driver might misreport its capabilities, causing WPF to take a code path that ends up causing some DirectX / D3D failure. Or, perhaps the driver didn't misreport its capabilities, but they just weren't implemented well. Regardless, the majority of XP/2003 related render thread failures was due to WPF attempting to utilize the hardware rendering pipeline which ended up exposing some flaw in the driver. Even on more modern versions of Windows, this can still happen, it's just not as common as it used to be. This is why one of our first suggestions for testing and/or working around a render thread failure is to try disabling hardware acceleration in WPF.

> Another common reason we might see render thread failures is due to the use of layered windows, particularly in Windows XP / 2003. Much of the layered windows implementation in XP is fragile, to say the least, with a number of bugs that impacted WPF significantly. These problems are most often exposed when you enable the Window.AllowsTransparency or Popup.AllowsTransparency properties in WPF, which will cause layered windows to be used. Starting in Windows Vista, most of the layered window problems in Windows have been addressed with the introduction of the Desktop Window Manager (DWM).




References:

[wpf_out_of_memory]: http://www.cnblogs.com/Curry/p/3417590.html
[WPF Out Of Memory][wpf_out_of_memory]
[outofmemoryexception_when_opening_radwindow]: http://www.telerik.com/forums/outofmemoryexception-when-opening-radwindow
[OutOfMemoryException when opening RadWindow][outofmemoryexception_when_opening_radwindow]
[outofmemory_exception_when_trying_to_drag_a_window]: http://www.infragistics.com/community/forums/t/76095.aspx
[OutOfMemoryException while trying to drag a window][outofmemory_exception_when_trying_to_drag_a_window]
[wpf_render_thread_failures]: http://blogs.msdn.com/b/dsui_team/archive/2013/11/18/wpf-render-thread-failures.aspx
[wpf_render_thread_failures][wpf_render_thread_failures]


## DevExpress RestoreLayout won't work if Element is backgrounded
the restore call won't reliably work if the element is backgrounded. 

there is a genrela trick that I played 

```
IsInChangingLayout = true;
LayoutViewModel dummy;
LoadIn(editingLayout, out dummy);
CancelStopLayout(editingLayout);
var isVisible = editingLayout.IsVisible;

// Viewer: Add a checkbox in the Manage Layouts dialog to make a layout 'always available'
// there is a defect in terms of the DevExpress DockLayout manager in that the restoration can only happen when 
// the relevant element is Visible.
// the workaround is to temporarily Visibile the layout, do the proper creation/restoration and then set back the 
// visibility flags.
// in the blink of transition, hoping user won't be ale to notice the changes.
editingLayout.IsVisible = true;
LoadsDocumentsIfNotLoaded(editingLayout);
IsInChangingLayout = false;
editingLayout.IsVisible = isVisible;
bool wasInCache = false;
if (LayoutsCacheManager.Contains(editingLayout.Name))
{
    wasInCache = true;
    LayoutsCacheManager.Remove(editingLayout.Name);
}
Log.InfoFormat("*{0}* - Pin layout '{1}'{2}", Type.Name, editingLayout.Name, wasInCache ? "(cached)" : string.Empty);
```


while things that baffled me is that given if the layout under editing is not added to the Presenter, and is background (meaning that the layout manager may not be created in the first place), without the trick it works just fine. It could be possibly because the RestoreLayout call does not happen on site, but happens when the Layout Manager is first loaded and displayed. (when first the Visibile is set to true).... 

however, seems that the trick does not blicks the UI or whatever affects the UI in some adverse manner. I would like to go this way.


## the way to add/remove event handler (the event handler's implementation)


First let me give you some code to study 

```
    public event EventHandler RequestClose
    {
      add
      {
        EventHandler eventHandler = this.RequestClose;
        EventHandler comparand;
        do
        {
          comparand = eventHandler;
          eventHandler = Interlocked.CompareExchange<EventHandler>(ref this.RequestClose, comparand + value, comparand);
        }
        while (eventHandler != comparand);
      }
      remove
      {
        EventHandler eventHandler = this.RequestClose;
        EventHandler comparand;
        do
        {
          comparand = eventHandler;
          eventHandler = Interlocked.CompareExchange<EventHandler>(ref this.RequestClose, comparand - value, comparand);
        }
        while (eventHandler != comparand);
      }
    }
```


why do we need to do that? 


suppose there are more than one client that is requesting to modify the event handler, for simplicity, we suppose there are two participants 

1. first thread goes into the do-while loop, before Interlocked, it yield
2. second thread kicks in and goes out of the look and it is done, leave the RequestClose updated. 
3. the first thread continue, and because comparand is different from the RequestClose handler, the compare exchange does not happen, and eventHandler is now the updated RequestClose 
4. at the loop condition expression part, because the condition yield to false, it continue the steps above.

## Handling of the window closing event with WPF/MVVM Light toolkit

there are many a way to deal with the closing of window. 

1. with a EventTrigger 
```
    <i:Interaction.Triggers>
        <i:EventTrigger EventName="Closing">
            <cmd:EventToCommand Command="{Binding CloseCommand}" />
        </i:EventTrigger>
    </i:Interaction.Triggers>
```

this requires that you defines some cose command


2. If you have the window's View, you can just do the Window.Closing handler registration 

```
MyWindow() 
    {
        // Set up ViewModel, assign to DataContext etc.
        Closing += viewModel.OnWindowClosing;
    }

// and in the view model

public void OnWindowClosing(object sender, CancelEventArgs e) 
    {
       // Handle closing logic, set e.Cancel as needed
    }
```

3. Just handling the Application's main window's closing event. 

```
Application.Current.MainWindow.Closing += new CancelEventHandler(MainWindow_Closing);

void MainWindow_Closing(object sender, CancelEventArgs e)
{
            //Your code to handle the event
}
```

4. there are some customized framework that aiming to making shutdown easier.

```
<i:Interaction.Triggers>
    <i:EventTrigger EventName="Closing">
        <cmd:EventToCommand Command="{Binding WindowClosingCommand}" PassEventArgsToCommand="True" />
    </i:EventTrigger>
</i:Interaction.Triggers> 
```

then 

```
///<summary>
///  public RelayCommand<CancelEventArgs> WindowClosingCommand
///</summary>
public RelayCommand<CancelEventArgs> WindowClosingCommand { get; private set; }

        // Window Closing
        WindowClosingCommand = new RelayCommand<CancelEventArgs>((args) =>
                                                                      {
                                                                          ShutdownService.MainWindowClosing(args);
                                                                      },
                                                                      (args) => CanShutdown);
```

and then int the Shutdown Service 


```
/// <summary>
    ///   ask the application to shutdown
    /// </summary>
    public static void MainWindowClosing(CancelEventArgs e)
    {
        e.Cancel = true;  /// CANCEL THE CLOSE - let the shutdown service decide what to do with the shutdown request
        RequestShutdown();
    }
```

Now, the Shutdown service does this

```
/// <summary>
    ///   ask the application to shutdown
    /// </summary>
    public static void RequestShutdown()
    {

        // Unless one of the listeners aborted the shutdown, we proceed.  If they abort the shutdown, they are responsible for restarting it too.

        var shouldAbortShutdown = false;
        Logger.InfoFormat("Application starting shutdown at {0}...", DateTime.Now);
        var msg = new NotificationMessageAction<bool>(
            Notifications.ConfirmShutdown,
            shouldAbort => shouldAbortShutdown |= shouldAbort);

        // recipients should answer either true or false with msg.execute(true) etc.

        Messenger.Default.Send(msg, Notifications.ConfirmShutdown);

        if (!shouldAbortShutdown)
        {
            // This time it is for real
            Messenger.Default.Send(new NotificationMessage(Notifications.NotifyShutdown),
                                   Notifications.NotifyShutdown);
            Logger.InfoFormat("Application has shutdown at {0}", DateTime.Now);
            Application.Current.Shutdown();
        }
        else
            Logger.InfoFormat("Application shutdown aborted at {0}", DateTime.Now);
    }
    }
```


5. variation of 1, on the Application' startup code

```
protected override void OnStartup(StartupEventArgs e)
{
  base.OnStartup(e);
  // Create the ViewModel to attach the window to
  MainWindow window = new MainWindow();
  var viewModel = new MainWindowViewModel();

  // Create the handler that will allow the window to close when the viewModel asks.
  EventHandler handler = null;
  handler = delegate
  {
    //***Code here to decide on closing the application****
    //***returns resultClose which is true if we want to close***
    if(resultClose == true)
    {
      viewModel.RequestClose -= handler;
      window.Close();
    }
  }
  viewModel.RequestClose += handler;

  window.DataContaxt = viewModel;

  window.Show();

}
```

6. use of the ShellService

First you will need to reference the Shell Service 

```
    xmlns:shell="clr-namespace:Microsoft.Windows.Shell;assembly=Microsoft.Windows.Shell"
```


then you can with the wpf command input bindings, first translate to event handler, then try to call the ViewModels.

```
        private void CloseWindowCommand_Executed(object sender, ExecutedRoutedEventArgs e)
        {
            var dataContext = DataContext as DataViewerViewModel;
            if (dataContext != null)
            {
                dataContext.RequestClose += (o, arg) =>
                {
                    System.Console.WriteLine("Request close");
                };
            }
```



Refernces
[handling_of_the_window_closing_event]: http://stackoverflow.com/questions/3683450/handling-the-window-closing-event-with-wpf-mvvm-light-toolkit
[Handling the window closing event with WPF / MVVM Light Toolkit][handling_of_the_window_closing_event]

## Converting View code to behavior example, window closing 


In my app , I added the following code

```
        private readonly ICommand _closeCommand;
        private readonly IList<DelayTask> _delayTasks = new List<DelayTask>();
        
        #region Commands
        public ICommand CloseCommand
        {
            get
            {
                return _closeCommand;
            }
        }
        #endregion
        
        #region Events 

        public event CancelEventHandler RequestClose;
 
        #endregion
        
        public MyViewModel(
            MyFilterViewModel myFilterViewModel,
            MyLayoutManagerViewModel myLayoutManagerViewModel)
        {
            _myFilterViewModel = myFilterViewModel;
            _myLayoutManagerVm = myLayoutManagerViewModel;
            _closeCommand = new DelegateCommand<CancelEventArgs>(ExecuteClose);
        }
        
        #region Commands 
        private void ExecuteClose(CancelEventArgs e)
        {
            if (!MyLayoutManagerViewModel.UserSettingOptionsViewModel.EnableAutoSave ||
                MyLayoutManagerViewModel.IsUserImpersonating)
            {
                var result = MessageBoxResult.Cancel;
                if (CloseConfirm != null)
                {
                    result = CloseConfirm("You are on explicit save mode, do you want to save before exit?", "Save Changes");
                }

                switch (result)
                {
                    case MessageBoxResult.No:
                        break;
                    case MessageBoxResult.Cancel:
                        e.Cancel = true;
                        return;
                    case MessageBoxResult.Yes:
                        if (myLayoutManagerViewModel.SaveAllSettingsCommand.CanExecute(null))
                        {
                            myLayoutManagerViewModel.SaveAllSettingsCommand.Execute(null);
                        }

                        // how to ensure that saving all has been done?
                        bool busyWait = false;
                        new DelayTask(new TimeSpan(0, 0, 1), _delayTasks)
                            .Task
                            .ContinueWith(
                                t => busyWait = true,
                                CancellationToken.None,
                                TaskContinuationOptions.OnlyOnRanToCompletion,
                                TaskScheduler.Default);
                        while (!busyWait)
                        {
                        }

                        break;
                    default:
                        throw new InvalidOperationException(string.Format("Can not handle result type = '{0}'", result));
                }
            }

            var temp = RequestClose;
            if (temp != null)
            {
                temp(this, e);
            }
        }
        #endregion
```

while on the View code I have done some qute amout of work  to set them up.

```
    internal partial class ViewerView 
    {
        public ViewerView()
        {
            InitializeComponent();
            Loaded += ViewLoaded;
        }

        #region Private Helper
        private void ViewLoaded(object sender, RoutedEventArgs args)
        {
            var vm = DataContext as MyViewModel;
            if (vm != null)
            {
                vm.CloseConfirm = (msg, capt) => MessageBox.Show(msg, capt, MessageBoxButton.YesNoCancel);
            }

            var window = Window.GetWindow(this);
            if (window != null)
            {
                EventHandler closedHandler = null;
                closedHandler = (o, arg) =>
                    {
                        window.Closed -= closedHandler;
                        window.Closing -= ClosingHandler;
                    };
                window.Closed += closedHandler;
                window.Closing += ClosingHandler;
            }
        }

        private void ClosingHandler(object sender, CancelEventArgs args)
        {
            var vm = DataContext as MyViewModel;
            if (vm != null)
            {
                vm.CloseCommand.Execute(args);
            }
        }
        #endregion
    }
```

and after the refactoring, the code become like this:

```
using System;
using System.ComponentModel;
using System.Windows;
using System.Windows.Input;
using System.Windows.Interactivity;

namespace Viewer.UI.Behaviors
{
    /// <summary>
    /// Hosting Window behavior monitoring events such as closing.
    /// </summary>
    public class HostingWindowBehavior : Behavior<FrameworkElement>
    {
        #region DP (fields)
        public static readonly DependencyProperty ClosingCommandProperty =
            DependencyProperty.Register("ClosingCommand", typeof(ICommand), typeof(HostingWindowBehavior), new PropertyMetadata(default(ICommand)));

        public static readonly DependencyProperty ClosedCommandProperty =
            DependencyProperty.Register("ClosedCommand", typeof(ICommand), typeof(HostingWindowBehavior), new PropertyMetadata(default(ICommand)));
        #endregion 

        #region Fields
        private Window _hostingWindow;
        #endregion 

        #region DP

        public ICommand ClosingCommand
        {
            get { return (ICommand)GetValue(ClosingCommandProperty); }
            set { SetValue(ClosingCommandProperty, value); }
        }


        public ICommand ClosedCommand
        {
            get { return (ICommand)GetValue(ClosedCommandProperty); }
            set { SetValue(ClosedCommandProperty, value); }
        }
        #endregion

        #region Behavior
        protected override void OnAttached()
        {
            AssociatedObject.Loaded += AssociatedObjectLoaded;
            base.OnAttached();
        }

        protected override void OnDetaching() 
        {
            base.OnDetaching();
            AssociatedObject.Loaded -= AssociatedObjectLoaded;
            if (_hostingWindow != null)
            {
                _hostingWindow.Closed -= OnClosed;
                _hostingWindow.Closing -= OnClosing;
            }
        }
        #endregion

        #region Behavior Object Handlers
        private void AssociatedObjectLoaded(object sende, RoutedEventArgs args)
        {
            _hostingWindow  = Window.GetWindow(AssociatedObject);

            if (_hostingWindow != null)
            {
                _hostingWindow.Closed += OnClosed;
                _hostingWindow.Closing += OnClosing;
            }
        }

        private void OnClosing(object sender, CancelEventArgs args)
        {
            var closingCommand = ClosingCommand;
            if (closingCommand != null)
            {
                closingCommand.Execute(args);
            }
        }

        private void OnClosed(object sender, EventArgs args)
        {
            _hostingWindow.Closed -= OnClosed;
            _hostingWindow.Closing -= OnClosing;

            var closedCommand = ClosedCommand;
            if (closedCommand != null)
            {
                closedCommand.CanExecute(args);
            }
        }
        #endregion
    }
}
```

## Waiting on Delayed saving to complete

Suppose that you have many operations that works on a defered fashion....

well, the problem with that is when you want a close action to effect immediately, you cannot control when all the pending action shall be completed. 

A small but easily ignored fact is that while you are waiting on the tasks to complete, you should be watching not to block your UI because that will block the saving thread to get info for saving. 

There are generally two way that you can achieve this.

1. deffered waiting with flip-flop on saving callback - basically every new successfully saves will reset a waiting timer (delayed task) until no new callback coming within a predefined time
2. implements an explicit interface that carry out immediate saving operations.

Before introducing the two proposed solution, there is a third, well, I will wait n seconds before closing the UI...


```
        private void ExecuteClosing(CancelEventArgs e)
        {
            if (!MyLayoutManagerViewModel.UserSettingOptionsViewModel.EnableAutoSave ||
                MyLayoutManagerViewModel.IsUserImpersonating)
            {
                var result = MessageBoxResult.Cancel;
                if (CloseConfirm != null)
                {
                    result = CloseConfirm("You are on explicit save mode, do you want to save before exit?", "Save Changes");
                }

                switch (result)
                {
                    case MessageBoxResult.No:
                        break;
                    case MessageBoxResult.Cancel:
                        e.Cancel = true;
                        return;
                    case MessageBoxResult.Yes:
                        if (MyLayoutManagerViewModel.SaveAllSettingsCommand.CanExecute(null))
                        {
                            MyLayoutManagerViewModel.SaveAllSettingsCommand.Execute(null);
                        }

                        // how to ensure that saving all has been done?
                        bool busyWait = false;
                        new DelayTask(new TimeSpan(0, 0, 1), _delayTasks)
                            .Task
                            .ContinueWith(
                                t => busyWait = true,
                                CancellationToken.None,
                                TaskContinuationOptions.OnlyOnRanToCompletion,
                                TaskScheduler.Default);
                        while (!busyWait)
                        {
                        }

                        break;
                    default:
                        throw new InvalidOperationException(string.Format("Can not handle result type = '{0}'", result));
                }
            }

            var temp = RequestClose;
            if (temp != null)
            {
                temp(this, e);
            }
        }
```


## Thread.SpinWait.

when to use the Thread.SpinWait 

the condition to wait on the SpinWait is ...

References

[Thread_SpinWait]: http://msdn.microsoft.com/en-us/library/system.threading.thread.spinwait(v=vs.110).aspx
[Threasd.SpinWait Method][Thread_SpinWait]



## Simulate busy waiting

with the Yield/Sleep with checking variables?

```
                        _eventAggregator.GetEvent<FlushStateEvent>().Publish(FlushStateEventArgs.Empty);
                        var doneWaiting = false;
                        new DelayTask(TimeSpan.FromSeconds(1), _delayTasks)
                            .Task.ContinueWith(
                                t => doneWaiting = true,
                                CancellationToken.None,
                                TaskContinuationOptions.OnlyOnRanToCompletion,
                                TaskScheduler.Default);
                        while (!doneWaiting)
                        {
                            Thread.Yield();
                        }
```


with the EventHandle, you can do 

```
                        var eventHandle = new ManualResetEvent(false);
                        new DelayTask(TimeSpan.FromSeconds(1), _delayTasks)
                            .Task.ContinueWith(
                                t => eventHandle.Set(),
                                CancellationToken.None,
                                TaskContinuationOptions.OnlyOnRanToCompletion,
                                TaskScheduler.Default);
                        
                        if (!eventHandle.WaitOne(2000))
                        {
                            // Log waiting failure
                        }
```


Well, you can asl well replace the Sleep/Yield call with the SpinWait, however, that does not change the way how this methods wowrks fundamentally.

## Thoughts on replacing EventAggregator


I have created an interface that is called "IFlushState" with the following methods 

```
    internal interface IFlushState
    {
        /// <summary>
        /// Flush means no delayed, no buffered save.
        /// </summary>
        /// <param name="eventArgs">the Event args to flush</param>
        void Flush(FlushStateEventArgs eventArgs);
    }
```

and the EventClass is as such 

```
    internal class FlushStateEventArgs
    {
        public static readonly FlushStateEventArgs Empty = new FlushStateEventArgs();
    }
```

While to work with the EventAggregator, here is the code. 

```
    /// <summary>
    /// Events consumed by Event Aggregator with <see cref="FlushStateEventArgs"/>
    /// </summary>
    internal class FlushStateEvent : CompositePresentationEvent<FlushStateEventArgs>
    {
    }
```

To use that I Have to put /implements the following code (introducing the EventAggregator) 

```
    internal class ChangeSetSavingService<T, TItem> : IChangeSetSavingService<T, TItem>, IFlushState
        where T : ChangeTrackableViewModel<TItem>
        where TItem : class, INotifyPropertyChanged
    {
        public ChangeSetSavingService(T changeSet, IEventAggregator eventAggregator)
        {
            _changeSet = changeSet;
            _cancellationTokenSource = new CancellationTokenSource();
            _eventAggregator = eventAggregator;
            _eventAggregator.GetEvent<FlushStateEvent>().Subscribe(Flush);
        }
        
        public void Flush(FlushStateEventArgs eventArgs)
        {
            Interlocked.Exchange(ref _cancellationTokenSource, new CancellationTokenSource()).Cancel();
            if (_changeSet != null)
            {
                _changeSet.Accept.Execute();
            }
        }
    }
```


While you can as well create the FlushStateManager, which has the following code. 


```

class FlushStateManager
{
    void Register(IFlushState flushState) 
    {
    }
    
    void Unregister(IFlushState flushState)
    {
    }
    
    void Flush()
    {
        foreach (var flush in FlushList) 
        {
            flush.Flush();
        }
    }

}

```

and in the above code , you would like to have 


```
    internal class ChangeSetSavingService<T, TItem> : IChangeSetSavingService<T, TItem>, IFlushState
        where T : ChangeTrackableViewModel<TItem>
        where TItem : class, INotifyPropertyChanged
    {
        public ChangeSetSavingService(T changeSet, FlushStateManager flushManager)
        {
            _changeSet = changeSet;
            _cancellationTokenSource = new CancellationTokenSource();
            _eventAggregator = eventAggregator;
            flushManager.Register(this);
        }
        
        public void Flush(FlushStateEventArgs eventArgs)
        {
            Interlocked.Exchange(ref _cancellationTokenSource, new CancellationTokenSource()).Cancel();
            if (_changeSet != null)
            {
                _changeSet.Accept.Execute();
            }
        }
    }
```


## how much is adequate sanity check

Given this: 
```
            Instances = new[] { DefaultInstance, "Asia", "America" };

```

you can just do this 
```
            _instance = string.IsNullOrEmpty(value)
                            ? DefaultInstance
                            : value;
```

```

            _instance = string.IsNullOrEmpty(value) || !Instances.Contains(value)
                            ? DefaultInstance
                            : value;
```


It is nevery end checking the status, it is your own judgement to tell how much is enough.

##  DevExpress Group row line template 

the group row does not have border, while if you want to cutomize the row style so that it can show a border/line if it has values to the left/right...

you can do the following 


```
<ControlTemplate x:Key="{dxgt:GridColumnHeaderThemeKey ResourceKey=ButtonContentTemplate}" TargetType="{x:Type ContentControl}">
        <Grid Height="40">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>
            <Border x:Name="rightBorder" Background="White" Grid.Column="1" Width="1" Visibility="{Binding HasRightSibling, Converter={StaticResource BooleanToVisibilityConverter}}"/>
            <Border x:Name="border1_1" VerticalAlignment="Stretch" HorizontalAlignment="Stretch" Grid.Column="0" Background="Gray" >
                <Grid Name="contentGrid" Background="red" VerticalAlignment="Stretch" HorizontalAlignment="Stretch">
                    <ContentPresenter x:Name="content" VerticalAlignment="Center" HorizontalAlignment="Stretch"/>
                </Grid>
            </Border>
        </Grid>
    </ControlTemplate>
```

the key here is the "HasRightSibling".


References
[how_to_change_lines]: https://www.devexpress.com/Support/Center/Question/Details/Q321542
[How to change lines][how_to_change_lines]

## ScrollViewer inside/outside of the TextBox 

While below is what I got from the TextBox template. 

```
    <Style 
        x:Key="TextBoxStyle" 
        TargetType="{x:Type TextBoxBase}">
        <Setter Property="SnapsToDevicePixels" Value="True"/>
        <Setter Property="OverridesDefaultStyle" Value="True"/>
        <Setter Property="KeyboardNavigation.TabNavigation" Value="None"/>
        <Setter Property="FocusVisualStyle" Value="{StaticResource FocusVisualStyle}"/>
        <Setter Property="MinWidth" Value="60"/>
        <Setter Property="MinHeight" Value="23"/>
        <Setter Property="AllowDrop" Value="true"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Padding" Value="2"/>
        <Setter Property="SelectionBrush" Value="{x:Static s:ModuleBrushes.SelectionBrush }"/>
        <Setter Property="Validation.ErrorTemplate" Value="{StaticResource InvalidBorderValidationControlTemplate}"/>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type TextBoxBase}">
                    <Border
                        Name="Border"
                        Padding="{TemplateBinding Padding}"
                        Background="{x:Static s:ModuleBrushes.DefaultBackgroundBrush}"
                        BorderBrush="{x:Static s:ModuleBrushes.DefaultBorderBrush}"
                        BorderThickness="{TemplateBinding BorderThickness}" 
                        Height="{TemplateBinding Height}">
                        <ScrollViewer 
                            Margin="0" 
                            x:Name="PART_ContentHost" 
                            Template="{StaticResource ScrollViewerTemplate}"/>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsEnabled" Value="False">
                            <Setter TargetName="Border" Property="Background" Value="{x:Static s:ModuleBrushes.DisabledBackgroundBrush}"/>
                            <Setter TargetName="Border" Property="BorderBrush" Value="{x:Static s:ModuleBrushes.DisabledBorderBrush}"/>
                            <Setter Property="Foreground" Value="{x:Static s:ModuleBrushes.DisabledForegroundBrush}"/>
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Setter Property="Foreground" Value="{x:Static s:ModuleBrushes.ForegroundBrush}"/>
        <Setter Property="CaretBrush" Value="{x:Static s:ModuleBrushes.ForegroundBrush}"/>
    </Style>
```

It has a ScrollViewer inside the template of the TextBox.

to draw an out border around the TextBox, what you might want to do is something like below.


```
<Border
    Margin="27, 17, 27, 0"
    BorderThickness="1"
    BorderBrush="{DynamicResource DefaultBorderBrush}">
    <ScrollViewer 
       HorizontalAlignment="Stretch"
       HorizontalContentAlignment="Left">
        <TextBox
           Margin="3,5,0,5"
           Style="{StaticResource TextBoxStyle}"
           Text="{Binding Filter}"
           TextWrapping="Wrap"
           AcceptsReturn="True"
           IsReadOnly="True"
           IsReadOnlyCaretVisible="True"
           ScrollViewer.VerticalScrollBarVisibility="Auto"
           BorderThickness="0"/>
    </ScrollViewer>
</Border>
```

However, the above code may have problems. 


```
<Border
    Margin="27, 17, 27, 0"
    BorderThickness="1"
    BorderBrush="{DynamicResource DefaultBorderBrush}">
    <ScrollViewer 
       HorizontalAlignment="Stretch"
       HorizontalContentAlignment="Left"
       VerticalScrollBarVisibility="Auto"
       HorizontalScrollBarVisibility="Disabled">
        <TextBox
           Margin="3,5,0,5"
           Style="{StaticResource TextBoxStyle}"
           Text="{Binding Filter}"
           TextWrapping="Wrap"
           AcceptsReturn="True"
           IsReadOnly="True"
           IsReadOnlyCaretVisible="True"
           ScrollViewer.VerticalScrollBarVisibility="Disabled"
            ScrollViewer.HorizontalScrollBarVisibility="Disabled"
           BorderThickness="0"/>
    </ScrollViewer>
</Border>
```

## Verify access vs. CheckAccess



while for the VerifyAccess call, there is such 

```
// System.Windows.Threading.Dispatcher
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] 
        public void VerifyAccess()
        {
            if(!CheckAccess())
            { 
                throw new InvalidOperationException(SR.Get(SRID.VerifyAccess));
            } 
```

while from the 

```
// System.Windows.Thrading.DispatcherObject
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public void VerifyAccess() 
        {
            // This method is free-threaded. 
 
            Dispatcher dispatcher = _dispatcher;
 
            // Note: a DispatcherObject that is not associated with a
            // dispatcher is considered to be free-threaded.
            if(dispatcher != null)
            { 
                dispatcher.VerifyAccess();
            } 
        } 
```


while check access is much simpler 

```
// System.Windows.Thrading.DispatcherObject

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public bool CheckAccess() 
        {
            // This method is free-threaded. 
 
            bool accessAllowed = true;
            Dispatcher dispatcher = _dispatcher; 

            // Note: a DispatcherObject that is not associated with a
            // dispatcher is considered to be free-threaded.
            if(dispatcher != null) 
            {
                accessAllowed = dispatcher.CheckAccess(); 
            } 

            return accessAllowed; 
        }
```

and the Dispatcher method is as such 


```
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public bool CheckAccess() 
        {
            return Thread == Thread.CurrentThread; 
        } 
```